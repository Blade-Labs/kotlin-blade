"use strict";
(self["webpackChunk_bladelabs_blade_sdk_js"] = self["webpackChunk_bladelabs_blade_sdk_js"] || []).push([["vendors-node_modules_is-ipfs_dist_src_index_js"],{

/***/ "./node_modules/iso-url/index.js":
/*!***************************************!*\
  !*** ./node_modules/iso-url/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const {
  URLWithLegacySupport,
  format,
  URLSearchParams,
  defaultBase
} = __webpack_require__(/*! ./src/url */ "./node_modules/iso-url/src/url-browser.js")
const relative = __webpack_require__(/*! ./src/relative */ "./node_modules/iso-url/src/relative.js")

module.exports = {
  URL: URLWithLegacySupport,
  URLSearchParams,
  format,
  relative,
  defaultBase
}


/***/ }),

/***/ "./node_modules/iso-url/src/relative.js":
/*!**********************************************!*\
  !*** ./node_modules/iso-url/src/relative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const { URLWithLegacySupport, format } = __webpack_require__(/*! ./url */ "./node_modules/iso-url/src/url-browser.js")

/**
 * @param {string | undefined} url
 * @param {any} [location]
 * @param {any} [protocolMap]
 * @param {any} [defaultProtocol]
 */
module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
  let protocol = location.protocol
    ? location.protocol.replace(':', '')
    : 'http'

  // Check protocol map
  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'
  let urlParsed

  try {
    urlParsed = new URLWithLegacySupport(url)
  } catch (err) {
    urlParsed = {}
  }

  const base = Object.assign({}, location, {
    protocol: protocol || urlParsed.protocol,
    host: location.host || urlParsed.host
  })

  return new URLWithLegacySupport(url, format(base)).toString()
}


/***/ }),

/***/ "./node_modules/iso-url/src/url-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/iso-url/src/url-browser.js ***!
  \*************************************************/
/***/ ((module) => {



const isReactNative =
    typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative'

function getDefaultBase () {
  if (isReactNative) {
    return 'http://localhost'
  }
  // in some environments i.e. cloudflare workers location is not available
  if (!self.location) {
    return ''
  }

  return self.location.protocol + '//' + self.location.host
}

const URL = self.URL
const defaultBase = getDefaultBase()

class URLWithLegacySupport {
  constructor (url = '', base = defaultBase) {
    this.super = new URL(url, base)
    this.path = this.pathname + this.search
    this.auth =
            this.username && this.password
              ? this.username + ':' + this.password
              : null

    this.query =
            this.search && this.search.startsWith('?')
              ? this.search.slice(1)
              : null
  }

  get hash () {
    return this.super.hash
  }

  get host () {
    return this.super.host
  }

  get hostname () {
    return this.super.hostname
  }

  get href () {
    return this.super.href
  }

  get origin () {
    return this.super.origin
  }

  get password () {
    return this.super.password
  }

  get pathname () {
    return this.super.pathname
  }

  get port () {
    return this.super.port
  }

  get protocol () {
    return this.super.protocol
  }

  get search () {
    return this.super.search
  }

  get searchParams () {
    return this.super.searchParams
  }

  get username () {
    return this.super.username
  }

  set hash (hash) {
    this.super.hash = hash
  }

  set host (host) {
    this.super.host = host
  }

  set hostname (hostname) {
    this.super.hostname = hostname
  }

  set href (href) {
    this.super.href = href
  }

  set password (password) {
    this.super.password = password
  }

  set pathname (pathname) {
    this.super.pathname = pathname
  }

  set port (port) {
    this.super.port = port
  }

  set protocol (protocol) {
    this.super.protocol = protocol
  }

  set search (search) {
    this.super.search = search
  }

  set username (username) {
    this.super.username = username
  }

  /**
   * @param {any} o
   */
  static createObjectURL (o) {
    return URL.createObjectURL(o)
  }

  /**
   * @param {string} o
   */
  static revokeObjectURL (o) {
    URL.revokeObjectURL(o)
  }

  toJSON () {
    return this.super.toJSON()
  }

  toString () {
    return this.super.toString()
  }

  format () {
    return this.toString()
  }
}

/**
 * @param {string | import('url').UrlObject} obj
 */
function format (obj) {
  if (typeof obj === 'string') {
    const url = new URL(obj)

    return url.toString()
  }

  if (!(obj instanceof URL)) {
    const userPass =
            // @ts-ignore its not supported in node but we normalise
            obj.username && obj.password
              // @ts-ignore its not supported in node but we normalise
              ? `${obj.username}:${obj.password}@`
              : ''
    const auth = obj.auth ? obj.auth + '@' : ''
    const port = obj.port ? ':' + obj.port : ''
    const protocol = obj.protocol ? obj.protocol + '//' : ''
    const host = obj.host || ''
    const hostname = obj.hostname || ''
    const search = obj.search || (obj.query ? '?' + obj.query : '')
    const hash = obj.hash || ''
    const pathname = obj.pathname || ''
    // @ts-ignore - path is not supported in node but we normalise
    const path = obj.path || pathname + search

    return `${protocol}${userPass || auth}${
            host || hostname + port
        }${path}${hash}`
  }
}

module.exports = {
  URLWithLegacySupport,
  URLSearchParams: self.URLSearchParams,
  defaultBase,
  format
}


/***/ }),

/***/ "./node_modules/@chainsafe/is-ip/lib/is-ip.js":
/*!****************************************************!*\
  !*** ./node_modules/@chainsafe/is-ip/lib/is-ip.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ipVersion: () => (/* binding */ ipVersion),
/* harmony export */   isIP: () => (/* binding */ isIP),
/* harmony export */   isIPv4: () => (/* binding */ isIPv4),
/* harmony export */   isIPv6: () => (/* binding */ isIPv6)
/* harmony export */ });
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "./node_modules/@chainsafe/is-ip/lib/parse.js");

/** Check if `input` is IPv4. */
function isIPv4(input) {
    return Boolean((0,_parse_js__WEBPACK_IMPORTED_MODULE_0__.parseIPv4)(input));
}
/** Check if `input` is IPv6. */
function isIPv6(input) {
    return Boolean((0,_parse_js__WEBPACK_IMPORTED_MODULE_0__.parseIPv6)(input));
}
/** Check if `input` is IPv4 or IPv6. */
function isIP(input) {
    return Boolean((0,_parse_js__WEBPACK_IMPORTED_MODULE_0__.parseIP)(input));
}
/**
 * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.
 */
function ipVersion(input) {
    if (isIPv4(input)) {
        return 4;
    }
    else if (isIPv6(input)) {
        return 6;
    }
    else {
        return undefined;
    }
}
//# sourceMappingURL=is-ip.js.map

/***/ }),

/***/ "./node_modules/@chainsafe/is-ip/lib/parse.js":
/*!****************************************************!*\
  !*** ./node_modules/@chainsafe/is-ip/lib/parse.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseIP: () => (/* binding */ parseIP),
/* harmony export */   parseIPv4: () => (/* binding */ parseIPv4),
/* harmony export */   parseIPv6: () => (/* binding */ parseIPv6)
/* harmony export */ });
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser.js */ "./node_modules/@chainsafe/is-ip/lib/parser.js");

// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser = new _parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser();
/** Parse `input` into IPv4 bytes. */
function parseIPv4(input) {
    if (input.length > MAX_IPV4_LENGTH) {
        return undefined;
    }
    return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
/** Parse `input` into IPv6 bytes. */
function parseIPv6(input) {
    // strip zone index if it is present
    if (input.includes("%")) {
        input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
        return undefined;
    }
    return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
/** Parse `input` into IPv4 or IPv6 bytes. */
function parseIP(input) {
    // strip zone index if it is present
    if (input.includes("%")) {
        input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
        return undefined;
    }
    return parser.new(input).parseWith(() => parser.readIPAddr());
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "./node_modules/@chainsafe/is-ip/lib/parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/@chainsafe/is-ip/lib/parser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Parser: () => (/* binding */ Parser)
/* harmony export */ });
/* eslint-disable @typescript-eslint/no-unsafe-return */
class Parser {
    index = 0;
    input = "";
    new(input) {
        this.index = 0;
        this.input = input;
        return this;
    }
    /** Run a parser, and restore the pre-parse state if it fails. */
    readAtomically(fn) {
        const index = this.index;
        const result = fn();
        if (result === undefined) {
            this.index = index;
        }
        return result;
    }
    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
    parseWith(fn) {
        const result = fn();
        if (this.index !== this.input.length) {
            return undefined;
        }
        return result;
    }
    /** Peek the next character from the input */
    peekChar() {
        if (this.index >= this.input.length) {
            return undefined;
        }
        return this.input[this.index];
    }
    /** Read the next character from the input */
    readChar() {
        if (this.index >= this.input.length) {
            return undefined;
        }
        return this.input[this.index++];
    }
    /** Read the next character from the input if it matches the target. */
    readGivenChar(target) {
        return this.readAtomically(() => {
            const char = this.readChar();
            if (char !== target) {
                return undefined;
            }
            return char;
        });
    }
    /**
     * Helper for reading separators in an indexed loop. Reads the separator
     * character iff index > 0, then runs the parser. When used in a loop,
     * the separator character will only be read on index > 0 (see
     * readIPv4Addr for an example)
     */
    readSeparator(sep, index, inner) {
        return this.readAtomically(() => {
            if (index > 0) {
                if (this.readGivenChar(sep) === undefined) {
                    return undefined;
                }
            }
            return inner();
        });
    }
    /**
     * Read a number off the front of the input in the given radix, stopping
     * at the first non-digit character or eof. Fails if the number has more
     * digits than max_digits or if there is no number.
     */
    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
        return this.readAtomically(() => {
            let result = 0;
            let digitCount = 0;
            const leadingChar = this.peekChar();
            if (leadingChar === undefined) {
                return undefined;
            }
            const hasLeadingZero = leadingChar === "0";
            const maxValue = 2 ** (8 * maxBytes) - 1;
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const digit = this.readAtomically(() => {
                    const char = this.readChar();
                    if (char === undefined) {
                        return undefined;
                    }
                    const num = Number.parseInt(char, radix);
                    if (Number.isNaN(num)) {
                        return undefined;
                    }
                    return num;
                });
                if (digit === undefined) {
                    break;
                }
                result *= radix;
                result += digit;
                if (result > maxValue) {
                    return undefined;
                }
                digitCount += 1;
                if (maxDigits !== undefined) {
                    if (digitCount > maxDigits) {
                        return undefined;
                    }
                }
            }
            if (digitCount === 0) {
                return undefined;
            }
            else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
                return undefined;
            }
            else {
                return result;
            }
        });
    }
    /** Read an IPv4 address. */
    readIPv4Addr() {
        return this.readAtomically(() => {
            const out = new Uint8Array(4);
            for (let i = 0; i < out.length; i++) {
                const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
                if (ix === undefined) {
                    return undefined;
                }
                out[i] = ix;
            }
            return out;
        });
    }
    /** Read an IPv6 Address. */
    readIPv6Addr() {
        /**
         * Read a chunk of an IPv6 address into `groups`. Returns the number
         * of groups read, along with a bool indicating if an embedded
         * trailing IPv4 address was read. Specifically, read a series of
         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional
         * trailing embedded IPv4 address.
         */
        const readGroups = (groups) => {
            for (let i = 0; i < groups.length / 2; i++) {
                const ix = i * 2;
                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.
                if (i < groups.length - 3) {
                    const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
                    if (ipv4 !== undefined) {
                        groups[ix] = ipv4[0];
                        groups[ix + 1] = ipv4[1];
                        groups[ix + 2] = ipv4[2];
                        groups[ix + 3] = ipv4[3];
                        return [ix + 4, true];
                    }
                }
                const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
                if (group === undefined) {
                    return [ix, false];
                }
                groups[ix] = group >> 8;
                groups[ix + 1] = group & 255;
            }
            return [groups.length, false];
        };
        return this.readAtomically(() => {
            // Read the front part of the address; either the whole thing, or up to the first ::
            const head = new Uint8Array(16);
            const [headSize, headIp4] = readGroups(head);
            if (headSize === 16) {
                return head;
            }
            // IPv4 part is not allowed before `::`
            if (headIp4) {
                return undefined;
            }
            // Read `::` if previous code parsed less than 8 groups.
            // `::` indicates one or more groups of 16 bits of zeros.
            if (this.readGivenChar(":") === undefined) {
                return undefined;
            }
            if (this.readGivenChar(":") === undefined) {
                return undefined;
            }
            // Read the back part of the address. The :: must contain at least one
            // set of zeroes, so our max length is 7.
            const tail = new Uint8Array(14);
            const limit = 16 - (headSize + 2);
            const [tailSize] = readGroups(tail.subarray(0, limit));
            // Concat the head and tail of the IP address
            head.set(tail.subarray(0, tailSize), 16 - tailSize);
            return head;
        });
    }
    /** Read an IP Address, either IPv4 or IPv6. */
    readIPAddr() {
        return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
}
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/cidr.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/cidr.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cidrMask: () => (/* binding */ cidrMask),
/* harmony export */   parseCidr: () => (/* binding */ parseCidr)
/* harmony export */ });
/* harmony import */ var _chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip/parse */ "./node_modules/@chainsafe/is-ip/lib/parse.js");
/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ip.js */ "./node_modules/@chainsafe/netmask/dist/src/ip.js");


function parseCidr(s) {
    const [address, maskString] = s.split("/");
    if (!address || !maskString)
        throw new Error("Failed to parse given CIDR: " + s);
    let ipLength = _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv4Len;
    let ip = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIPv4)(address);
    if (ip == null) {
        ipLength = _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv6Len;
        ip = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIPv6)(address);
        if (ip == null)
            throw new Error("Failed to parse given CIDR: " + s);
    }
    const m = parseInt(maskString, 10);
    if (Number.isNaN(m) ||
        String(m).length !== maskString.length ||
        m < 0 ||
        m > ipLength * 8) {
        throw new Error("Failed to parse given CIDR: " + s);
    }
    const mask = cidrMask(m, 8 * ipLength);
    return {
        network: (0,_ip_js__WEBPACK_IMPORTED_MODULE_1__.maskIp)(ip, mask),
        mask,
    };
}
function cidrMask(ones, bits) {
    if (bits !== 8 * _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv4Len && bits !== 8 * _ip_js__WEBPACK_IMPORTED_MODULE_1__.IPv6Len)
        throw new Error("Invalid CIDR mask");
    if (ones < 0 || ones > bits)
        throw new Error("Invalid CIDR mask");
    const l = bits / 8;
    const m = new Uint8Array(l);
    for (let i = 0; i < l; i++) {
        if (ones >= 8) {
            m[i] = 0xff;
            ones -= 8;
            continue;
        }
        m[i] = 255 - (0xff >> ones);
        ones = 0;
    }
    return m;
}
//# sourceMappingURL=cidr.js.map

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IpNet: () => (/* reexport safe */ _ipnet_js__WEBPACK_IMPORTED_MODULE_0__.IpNet),
/* harmony export */   cidrContains: () => (/* binding */ cidrContains),
/* harmony export */   iPv4FromIPv6: () => (/* reexport safe */ _ip_js__WEBPACK_IMPORTED_MODULE_2__.iPv4FromIPv6),
/* harmony export */   ipToString: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_1__.ipToString),
/* harmony export */   isIPv4mappedIPv6: () => (/* reexport safe */ _ip_js__WEBPACK_IMPORTED_MODULE_2__.isIPv4mappedIPv6),
/* harmony export */   maskIp: () => (/* reexport safe */ _ip_js__WEBPACK_IMPORTED_MODULE_2__.maskIp),
/* harmony export */   parseCidr: () => (/* reexport safe */ _cidr_js__WEBPACK_IMPORTED_MODULE_3__.parseCidr)
/* harmony export */ });
/* harmony import */ var _ipnet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ipnet.js */ "./node_modules/@chainsafe/netmask/dist/src/ipnet.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/@chainsafe/netmask/dist/src/util.js");
/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ip.js */ "./node_modules/@chainsafe/netmask/dist/src/ip.js");
/* harmony import */ var _cidr_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cidr.js */ "./node_modules/@chainsafe/netmask/dist/src/cidr.js");





/**
 * Checks if cidr block contains ip address
 * @param cidr ipv4 or ipv6 formatted cidr . Example 198.51.100.14/24 or 2001:db8::/48
 * @param ip ipv4 or ipv6 address Example 198.51.100.14 or 2001:db8::
 *
 */
function cidrContains(cidr, ip) {
    const ipnet = new _ipnet_js__WEBPACK_IMPORTED_MODULE_0__.IpNet(cidr);
    return ipnet.contains(ip);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/ip.js":
/*!********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/ip.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IPv4Len: () => (/* binding */ IPv4Len),
/* harmony export */   IPv6Len: () => (/* binding */ IPv6Len),
/* harmony export */   containsIp: () => (/* binding */ containsIp),
/* harmony export */   iPv4FromIPv6: () => (/* binding */ iPv4FromIPv6),
/* harmony export */   ipv4Prefix: () => (/* binding */ ipv4Prefix),
/* harmony export */   isIPv4mappedIPv6: () => (/* binding */ isIPv4mappedIPv6),
/* harmony export */   maskIp: () => (/* binding */ maskIp),
/* harmony export */   maxIPv6Octet: () => (/* binding */ maxIPv6Octet)
/* harmony export */ });
/* harmony import */ var _chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip/parse */ "./node_modules/@chainsafe/is-ip/lib/parse.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/@chainsafe/netmask/dist/src/util.js");


const IPv4Len = 4;
const IPv6Len = 16;
const maxIPv6Octet = parseInt("0xFFFF", 16);
const ipv4Prefix = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,
]);
function maskIp(ip, mask) {
    if (mask.length === IPv6Len && ip.length === IPv4Len && (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.allFF)(mask, 0, 11)) {
        mask = mask.slice(12);
    }
    if (mask.length === IPv4Len &&
        ip.length === IPv6Len &&
        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(ip, ipv4Prefix, 0, 11)) {
        ip = ip.slice(12);
    }
    const n = ip.length;
    if (n != mask.length) {
        throw new Error("Failed to mask ip");
    }
    const out = new Uint8Array(n);
    for (let i = 0; i < n; i++) {
        out[i] = ip[i] & mask[i];
    }
    return out;
}
function containsIp(net, ip) {
    if (typeof ip === "string") {
        ip = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIP)(ip);
    }
    if (ip == null)
        throw new Error("Invalid ip");
    if (ip.length !== net.network.length) {
        return false;
    }
    for (let i = 0; i < ip.length; i++) {
        if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {
            return false;
        }
    }
    return true;
}
function iPv4FromIPv6(ip) {
    if (!isIPv4mappedIPv6(ip)) {
        throw new Error("Must have 0xffff prefix");
    }
    return ip.slice(12);
}
function isIPv4mappedIPv6(ip) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(ip, ipv4Prefix, 0, 11);
}
//# sourceMappingURL=ip.js.map

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/ipnet.js":
/*!***********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/ipnet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IpNet: () => (/* binding */ IpNet)
/* harmony export */ });
/* harmony import */ var _chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip/parse */ "./node_modules/@chainsafe/is-ip/lib/parse.js");
/* harmony import */ var _cidr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cidr.js */ "./node_modules/@chainsafe/netmask/dist/src/cidr.js");
/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ip.js */ "./node_modules/@chainsafe/netmask/dist/src/ip.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ "./node_modules/@chainsafe/netmask/dist/src/util.js");




class IpNet {
    /**
     *
     * @param ipOrCidr either network ip or full cidr address
     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
     */
    constructor(ipOrCidr, mask) {
        if (mask == null) {
            ({ network: this.network, mask: this.mask } = (0,_cidr_js__WEBPACK_IMPORTED_MODULE_1__.parseCidr)(ipOrCidr));
        }
        else {
            const ipResult = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIP)(ipOrCidr);
            if (ipResult == null) {
                throw new Error("Failed to parse network");
            }
            mask = String(mask);
            const m = parseInt(mask, 10);
            if (Number.isNaN(m) ||
                String(m).length !== mask.length ||
                m < 0 ||
                m > ipResult.length * 8) {
                const maskResult = (0,_chainsafe_is_ip_parse__WEBPACK_IMPORTED_MODULE_0__.parseIP)(mask);
                if (maskResult == null) {
                    throw new Error("Failed to parse mask");
                }
                this.mask = maskResult;
            }
            else {
                this.mask = (0,_cidr_js__WEBPACK_IMPORTED_MODULE_1__.cidrMask)(m, 8 * ipResult.length);
            }
            this.network = (0,_ip_js__WEBPACK_IMPORTED_MODULE_2__.maskIp)(ipResult, this.mask);
        }
    }
    /**
     * Checks if netmask contains ip address
     * @param ip
     * @returns
     */
    contains(ip) {
        return (0,_ip_js__WEBPACK_IMPORTED_MODULE_2__.containsIp)({ network: this.network, mask: this.mask }, ip);
    }
    /**Serializes back to string format */
    toString() {
        const l = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.simpleMaskLength)(this.mask);
        const mask = l !== -1 ? String(l) : (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.maskToHex)(this.mask);
        return (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.ipToString)(this.network) + "/" + mask;
    }
}
//# sourceMappingURL=ipnet.js.map

/***/ }),

/***/ "./node_modules/@chainsafe/netmask/dist/src/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chainsafe/netmask/dist/src/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   allFF: () => (/* binding */ allFF),
/* harmony export */   deepEqual: () => (/* binding */ deepEqual),
/* harmony export */   ipToString: () => (/* binding */ ipToString),
/* harmony export */   maskToHex: () => (/* binding */ maskToHex),
/* harmony export */   simpleMaskLength: () => (/* binding */ simpleMaskLength)
/* harmony export */ });
/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ip.js */ "./node_modules/@chainsafe/netmask/dist/src/ip.js");

function allFF(a, from, to) {
    let i = 0;
    for (const e of a) {
        if (i < from)
            continue;
        if (i > to)
            break;
        if (e !== 0xff)
            return false;
        i++;
    }
    return true;
}
function deepEqual(a, b, from, to) {
    let i = 0;
    for (const e of a) {
        if (i < from)
            continue;
        if (i > to)
            break;
        if (e !== b[i])
            return false;
        i++;
    }
    return true;
}
/***
 * Returns long ip format
 */
function ipToString(ip) {
    switch (ip.length) {
        case _ip_js__WEBPACK_IMPORTED_MODULE_0__.IPv4Len: {
            return ip.join(".");
        }
        case _ip_js__WEBPACK_IMPORTED_MODULE_0__.IPv6Len: {
            const result = [];
            for (let i = 0; i < ip.length; i++) {
                if (i % 2 === 0) {
                    result.push(ip[i].toString(16).padStart(2, "0") +
                        ip[i + 1].toString(16).padStart(2, "0"));
                }
            }
            return result.join(":");
        }
        default: {
            throw new Error("Invalid ip length");
        }
    }
}
/**
 * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1
 */
function simpleMaskLength(mask) {
    let ones = 0;
    // eslint-disable-next-line prefer-const
    for (let [index, byte] of mask.entries()) {
        if (byte === 0xff) {
            ones += 8;
            continue;
        }
        while ((byte & 0x80) != 0) {
            ones++;
            byte = byte << 1;
        }
        if ((byte & 0x80) != 0) {
            return -1;
        }
        for (let i = index + 1; i < mask.length; i++) {
            if (mask[i] != 0) {
                return -1;
            }
        }
        break;
    }
    return ones;
}
function maskToHex(mask) {
    let hex = "0x";
    for (const byte of mask) {
        hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);
    }
    return hex;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@libp2p/interface/dist/src/errors.js":
/*!***********************************************************!*\
  !*** ./node_modules/@libp2p/interface/dist/src/errors.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* binding */ AbortError),
/* harmony export */   AggregateCodeError: () => (/* binding */ AggregateCodeError),
/* harmony export */   CodeError: () => (/* binding */ CodeError),
/* harmony export */   ERR_INVALID_MESSAGE: () => (/* binding */ ERR_INVALID_MESSAGE),
/* harmony export */   ERR_INVALID_PARAMETERS: () => (/* binding */ ERR_INVALID_PARAMETERS),
/* harmony export */   ERR_NOT_FOUND: () => (/* binding */ ERR_NOT_FOUND),
/* harmony export */   ERR_TIMEOUT: () => (/* binding */ ERR_TIMEOUT),
/* harmony export */   InvalidCryptoExchangeError: () => (/* binding */ InvalidCryptoExchangeError),
/* harmony export */   InvalidCryptoTransmissionError: () => (/* binding */ InvalidCryptoTransmissionError),
/* harmony export */   UnexpectedPeerError: () => (/* binding */ UnexpectedPeerError)
/* harmony export */ });
/**
 * When this error is thrown it means an operation was aborted,
 * usually in response to the `abort` event being emitted by an
 * AbortSignal.
 */
class AbortError extends Error {
    code;
    type;
    constructor(message = 'The operation was aborted') {
        super(message);
        this.name = 'AbortError';
        this.code = AbortError.code;
        this.type = AbortError.type;
    }
    static code = 'ABORT_ERR';
    static type = 'aborted';
}
class CodeError extends Error {
    code;
    props;
    constructor(message, code, props) {
        super(message);
        this.code = code;
        this.name = props?.name ?? 'CodeError';
        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions
    }
}
class AggregateCodeError extends AggregateError {
    code;
    props;
    constructor(errors, message, code, props) {
        super(errors, message);
        this.code = code;
        this.name = props?.name ?? 'AggregateCodeError';
        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions
    }
}
class UnexpectedPeerError extends Error {
    code;
    constructor(message = 'Unexpected Peer') {
        super(message);
        this.name = 'UnexpectedPeerError';
        this.code = UnexpectedPeerError.code;
    }
    static code = 'ERR_UNEXPECTED_PEER';
}
class InvalidCryptoExchangeError extends Error {
    code;
    constructor(message = 'Invalid crypto exchange') {
        super(message);
        this.name = 'InvalidCryptoExchangeError';
        this.code = InvalidCryptoExchangeError.code;
    }
    static code = 'ERR_INVALID_CRYPTO_EXCHANGE';
}
class InvalidCryptoTransmissionError extends Error {
    code;
    constructor(message = 'Invalid crypto transmission') {
        super(message);
        this.name = 'InvalidCryptoTransmissionError';
        this.code = InvalidCryptoTransmissionError.code;
    }
    static code = 'ERR_INVALID_CRYPTO_TRANSMISSION';
}
// Error codes
const ERR_TIMEOUT = 'ERR_TIMEOUT';
const ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS';
const ERR_NOT_FOUND = 'ERR_NOT_FOUND';
const ERR_INVALID_MESSAGE = 'ERR_INVALID_MESSAGE';
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/@multiformats/mafmt/dist/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@multiformats/mafmt/dist/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Circuit: () => (/* binding */ Circuit),
/* harmony export */   DNS: () => (/* binding */ DNS),
/* harmony export */   DNS4: () => (/* binding */ DNS4),
/* harmony export */   DNS6: () => (/* binding */ DNS6),
/* harmony export */   DNSADDR: () => (/* binding */ DNSADDR),
/* harmony export */   HTTP: () => (/* binding */ HTTP),
/* harmony export */   HTTPS: () => (/* binding */ HTTPS),
/* harmony export */   IP: () => (/* binding */ IP),
/* harmony export */   IPFS: () => (/* binding */ IPFS),
/* harmony export */   P2P: () => (/* binding */ P2P),
/* harmony export */   P2PWebRTCDirect: () => (/* binding */ P2PWebRTCDirect),
/* harmony export */   P2PWebRTCStar: () => (/* binding */ P2PWebRTCStar),
/* harmony export */   QUIC: () => (/* binding */ QUIC),
/* harmony export */   QUICV1: () => (/* binding */ QUICV1),
/* harmony export */   Reliable: () => (/* binding */ Reliable),
/* harmony export */   Stardust: () => (/* binding */ Stardust),
/* harmony export */   TCP: () => (/* binding */ TCP),
/* harmony export */   UDP: () => (/* binding */ UDP),
/* harmony export */   UTP: () => (/* binding */ UTP),
/* harmony export */   WebRTC: () => (/* binding */ WebRTC),
/* harmony export */   WebRTCDirect: () => (/* binding */ WebRTCDirect),
/* harmony export */   WebSocketStar: () => (/* binding */ WebSocketStar),
/* harmony export */   WebSockets: () => (/* binding */ WebSockets),
/* harmony export */   WebSocketsSecure: () => (/* binding */ WebSocketsSecure),
/* harmony export */   WebTransport: () => (/* binding */ WebTransport)
/* harmony export */ });
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");

/*
 * Valid combinations
 */
const DNS4 = base('dns4');
const DNS6 = base('dns6');
const DNSADDR = base('dnsaddr');
const DNS = or(base('dns'), DNSADDR, DNS4, DNS6);
const IP = or(base('ip4'), base('ip6'));
const TCP = or(and(IP, base('tcp')), and(DNS, base('tcp')));
const UDP = and(IP, base('udp'));
const UTP = and(UDP, base('utp'));
const QUIC = and(UDP, base('quic'));
const QUICV1 = and(UDP, base('quic-v1'));
const _WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));
const WebSockets = or(and(_WebSockets, base('p2p')), _WebSockets);
const _WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')), and(TCP, base('tls'), base('ws')), and(DNS, base('tls'), base('ws')));
const WebSocketsSecure = or(and(_WebSocketsSecure, base('p2p')), _WebSocketsSecure);
const HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')));
const HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));
const _WebRTCDirect = and(UDP, base('webrtc-direct'), base('certhash'));
const WebRTCDirect = or(and(_WebRTCDirect, base('p2p')), _WebRTCDirect);
const _WebTransport = and(QUICV1, base('webtransport'), base('certhash'), base('certhash'));
const WebTransport = or(and(_WebTransport, base('p2p')), _WebTransport);
/**
 * @deprecated
 */
const P2PWebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('p2p')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')), and(WebSockets, base('p2p-webrtc-star')), and(WebSocketsSecure, base('p2p-webrtc-star')));
const WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('p2p')), and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));
/**
 * @deprecated
 */
const P2PWebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct'), base('p2p')), and(HTTPS, base('p2p-webrtc-direct'), base('p2p')), and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));
const Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);
// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )
const Stardust = or(and(Reliable, base('p2p-stardust'), base('p2p')), and(Reliable, base('p2p-stardust')));
const _P2P = or(and(Reliable, base('p2p')), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base('p2p'));
const _Circuit = or(and(_P2P, base('p2p-circuit'), _P2P), and(_P2P, base('p2p-circuit')), and(base('p2p-circuit'), _P2P), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));
const CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);
const Circuit = CircuitRecursive();
const P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
const IPFS = P2P;
const WebRTC = or(and(Circuit, base('webrtc'), base('p2p')), and(Circuit, base('webrtc')), and(Reliable, base('webrtc'), base('p2p')), and(Reliable, base('webrtc')), base('webrtc'));
/*
 * Validation funcs
 */
function makeMatchesFunction(partialMatch) {
    function matches(a) {
        let ma;
        try {
            ma = (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(a);
        }
        catch (err) { // catch error
            return false; // also if it's invalid it's probably not matching as well so return false
        }
        const out = partialMatch(ma.protoNames());
        if (out === null) {
            return false;
        }
        if (out === true || out === false) {
            return out;
        }
        return out.length === 0;
    }
    return matches;
}
function and(...args) {
    function partialMatch(a) {
        if (a.length < args.length) {
            return null;
        }
        let out = a;
        args.some((arg) => {
            out = typeof arg === 'function'
                ? arg().partialMatch(a)
                : arg.partialMatch(a);
            if (Array.isArray(out)) {
                a = out;
            }
            if (out === null) {
                return true;
            }
            return false;
        });
        return out;
    }
    return {
        toString: function () { return '{ ' + args.join(' ') + ' }'; },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
    };
}
function or(...args) {
    function partialMatch(a) {
        let out = null;
        args.some((arg) => {
            const res = typeof arg === 'function'
                ? arg().partialMatch(a)
                : arg.partialMatch(a);
            if (res != null) {
                out = res;
                return true;
            }
            return false;
        });
        return out;
    }
    const result = {
        toString: function () { return '{ ' + args.join(' ') + ' }'; },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
    };
    return result;
}
function base(n) {
    const name = n;
    function matches(a) {
        let ma;
        try {
            ma = (0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_0__.multiaddr)(a);
        }
        catch (err) { // catch error
            return false; // also if it's invalid it's probably not matching as well so return false
        }
        const pnames = ma.protoNames();
        if (pnames.length === 1 && pnames[0] === name) {
            return true;
        }
        return false;
    }
    function partialMatch(protos) {
        if (protos.length === 0) {
            return null;
        }
        if (protos[0] === name) {
            return protos.slice(1);
        }
        return null;
    }
    return {
        toString: function () { return name; },
        matches,
        partialMatch
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/codec.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/codec.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParseError: () => (/* binding */ ParseError),
/* harmony export */   bytesToMultiaddrParts: () => (/* binding */ bytesToMultiaddrParts),
/* harmony export */   bytesToTuples: () => (/* binding */ bytesToTuples),
/* harmony export */   cleanPath: () => (/* binding */ cleanPath),
/* harmony export */   stringToMultiaddrParts: () => (/* binding */ stringToMultiaddrParts),
/* harmony export */   tuplesToBytes: () => (/* binding */ tuplesToBytes)
/* harmony export */ });
/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8-varint */ "./node_modules/uint8-varint/dist/src/index.js");
/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/concat */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");
/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./convert.js */ "./node_modules/@multiformats/multiaddr/dist/src/convert.js");
/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./protocols-table.js */ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js");





function stringToMultiaddrParts(str) {
    str = cleanPath(str);
    const tuples = [];
    const stringTuples = [];
    let path = null;
    const parts = str.split('/').slice(1);
    if (parts.length === 1 && parts[0] === '') {
        return {
            bytes: new Uint8Array(),
            string: '/',
            tuples: [],
            stringTuples: [],
            path: null
        };
    }
    for (let p = 0; p < parts.length; p++) {
        const part = parts[p];
        const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(part);
        if (proto.size === 0) {
            tuples.push([proto.code]);
            stringTuples.push([proto.code]);
            // eslint-disable-next-line no-continue
            continue;
        }
        p++; // advance addr part
        if (p >= parts.length) {
            throw ParseError('invalid address: ' + str);
        }
        // if it's a path proto, take the rest
        if (proto.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = cleanPath(parts.slice(p).join('/'));
            tuples.push([proto.code, (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToBytes)(proto.code, path)]);
            stringTuples.push([proto.code, path]);
            break;
        }
        const bytes = (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToBytes)(proto.code, parts[p]);
        tuples.push([proto.code, bytes]);
        stringTuples.push([proto.code, (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToString)(proto.code, bytes)]);
    }
    return {
        string: stringTuplesToString(stringTuples),
        bytes: tuplesToBytes(tuples),
        tuples,
        stringTuples,
        path
    };
}
function bytesToMultiaddrParts(bytes) {
    const tuples = [];
    const stringTuples = [];
    let path = null;
    let i = 0;
    while (i < bytes.length) {
        const code = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.decode(bytes, i);
        const n = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code);
        const p = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(code);
        const size = sizeForAddr(p, bytes.slice(i + n));
        if (size === 0) {
            tuples.push([code]);
            stringTuples.push([code]);
            i += n;
            // eslint-disable-next-line no-continue
            continue;
        }
        const addr = bytes.slice(i + n, i + n + size);
        i += (size + n);
        if (i > bytes.length) { // did not end _exactly_ at buffer.length
            throw ParseError('Invalid address Uint8Array: ' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(bytes, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([code, addr]);
        const stringAddr = (0,_convert_js__WEBPACK_IMPORTED_MODULE_3__.convertToString)(code, addr);
        stringTuples.push([code, stringAddr]);
        if (p.path === true) {
            // should we need to check each path part to see if it's a proto?
            // This would allow for other protocols to be added after a unix path,
            // however it would have issues if the path had a protocol name in the path
            path = stringAddr;
            break;
        }
    }
    return {
        bytes: Uint8Array.from(bytes),
        string: stringTuplesToString(stringTuples),
        tuples,
        stringTuples,
        path
    };
}
/**
 * [[str name, str addr]... ] -> string
 */
function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup) => {
        const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(tup[0]);
        parts.push(proto.name);
        if (tup.length > 1 && tup[1] != null) {
            parts.push(tup[1]);
        }
        return null;
    });
    return cleanPath(parts.join('/'));
}
/**
 * [[int code, Uint8Array ]... ] -> Uint8Array
 */
function tuplesToBytes(tuples) {
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(tuples.map((tup) => {
        const proto = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(tup[0]);
        let buf = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encode(proto.code));
        if (tup.length > 1 && tup[1] != null) {
            buf = (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_1__.concat)([buf, tup[1]]); // add address buffer
        }
        return buf;
    }));
}
/**
 * For the passed address, return the serialized size
 */
function sizeForAddr(p, addr) {
    if (p.size > 0) {
        return p.size / 8;
    }
    else if (p.size === 0) {
        return 0;
    }
    else {
        const size = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
        return size + uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(size);
    }
}
function bytesToTuples(buf) {
    const tuples = [];
    let i = 0;
    while (i < buf.length) {
        const code = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.decode(buf, i);
        const n = uint8_varint__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code);
        const p = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_4__.getProtocol)(code);
        const size = sizeForAddr(p, buf.slice(i + n));
        if (size === 0) {
            tuples.push([code]);
            i += n;
            // eslint-disable-next-line no-continue
            continue;
        }
        const addr = buf.slice(i + n, i + n + size);
        i += (size + n);
        if (i > buf.length) { // did not end _exactly_ at buffer.length
            throw ParseError('Invalid address Uint8Array: ' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(buf, 'base16'));
        }
        // ok, tuple seems good.
        tuples.push([code, addr]);
    }
    return tuples;
}
function cleanPath(str) {
    return '/' + str.trim().split('/').filter((a) => a).join('/');
}
function ParseError(str) {
    return new Error('Error parsing address: ' + str);
}
//# sourceMappingURL=codec.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/convert.js":
/*!******************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/convert.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convert: () => (/* binding */ convert),
/* harmony export */   convertToBytes: () => (/* binding */ convertToBytes),
/* harmony export */   convertToIpNet: () => (/* binding */ convertToIpNet),
/* harmony export */   convertToString: () => (/* binding */ convertToString)
/* harmony export */ });
/* harmony import */ var _chainsafe_netmask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/netmask */ "./node_modules/@chainsafe/netmask/dist/src/index.js");
/* harmony import */ var multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/bases/base32 */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js");
/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multiformats/bases/base58 */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js");
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/basics */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/cid */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js");
/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/hashes/digest */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js");
/* harmony import */ var uint8_varint__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uint8-varint */ "./node_modules/uint8-varint/dist/src/index.js");
/* harmony import */ var uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uint8arrays/concat */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js");
/* harmony import */ var uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uint8arrays/from-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");
/* harmony import */ var _ip_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ip.js */ "./node_modules/@multiformats/multiaddr/dist/src/ip.js");
/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./protocols-table.js */ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js");
/**
 * @packageDocumentation
 *
 * Provides methods for converting
 */












const ip4Protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)('ip4');
const ip6Protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)('ip6');
const ipcidrProtocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)('ipcidr');
function convert(proto, a) {
    if (a instanceof Uint8Array) {
        return convertToString(proto, a);
    }
    else {
        return convertToBytes(proto, a);
    }
}
/**
 * Convert [code,Uint8Array] to string
 */
function convertToString(proto, buf) {
    const protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)(proto);
    switch (protocol.code) {
        case 4: // ipv4
        case 41: // ipv6
            return bytes2ip(buf);
        case 42: // ipv6zone
            return bytes2str(buf);
        case 6: // tcp
        case 273: // udp
        case 33: // dccp
        case 132: // sctp
            return bytes2port(buf).toString();
        case 53: // dns
        case 54: // dns4
        case 55: // dns6
        case 56: // dnsaddr
        case 400: // unix
        case 449: // sni
        case 777: // memory
            return bytes2str(buf);
        case 421: // ipfs
            return bytes2mh(buf);
        case 444: // onion
            return bytes2onion(buf);
        case 445: // onion3
            return bytes2onion(buf);
        case 466: // certhash
            return bytes2mb(buf);
        case 481: // http-path
            return globalThis.encodeURIComponent(bytes2str(buf));
        default:
            return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(buf, 'base16'); // no clue. convert to hex
    }
}
function convertToBytes(proto, str) {
    const protocol = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_11__.getProtocol)(proto);
    switch (protocol.code) {
        case 4: // ipv4
            return ip2bytes(str);
        case 41: // ipv6
            return ip2bytes(str);
        case 42: // ipv6zone
            return str2bytes(str);
        case 6: // tcp
        case 273: // udp
        case 33: // dccp
        case 132: // sctp
            return port2bytes(parseInt(str, 10));
        case 53: // dns
        case 54: // dns4
        case 55: // dns6
        case 56: // dnsaddr
        case 400: // unix
        case 449: // sni
        case 777: // memory
            return str2bytes(str);
        case 421: // ipfs
            return mh2bytes(str);
        case 444: // onion
            return onion2bytes(str);
        case 445: // onion3
            return onion32bytes(str);
        case 466: // certhash
            return mb2bytes(str);
        case 481: // http-path
            return str2bytes(globalThis.decodeURIComponent(str));
        default:
            return (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_8__.fromString)(str, 'base16'); // no clue. convert from hex
    }
}
function convertToIpNet(multiaddr) {
    let mask;
    let addr;
    multiaddr.stringTuples().forEach(([code, value]) => {
        if (code === ip4Protocol.code || code === ip6Protocol.code) {
            addr = value;
        }
        if (code === ipcidrProtocol.code) {
            mask = value;
        }
    });
    if (mask == null || addr == null) {
        throw new Error('Invalid multiaddr');
    }
    return new _chainsafe_netmask__WEBPACK_IMPORTED_MODULE_0__.IpNet(addr, mask);
}
const decoders = Object.values(multiformats_basics__WEBPACK_IMPORTED_MODULE_3__.bases).map((c) => c.decoder);
const anybaseDecoder = (function () {
    let acc = decoders[0].or(decoders[1]);
    decoders.slice(2).forEach((d) => (acc = acc.or(d)));
    return acc;
})();
function ip2bytes(ipString) {
    if (!_ip_js__WEBPACK_IMPORTED_MODULE_10__.isIP(ipString)) {
        throw new Error('invalid ip address');
    }
    return _ip_js__WEBPACK_IMPORTED_MODULE_10__.toBytes(ipString);
}
function bytes2ip(ipBuff) {
    const ipString = _ip_js__WEBPACK_IMPORTED_MODULE_10__.toString(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
        throw new Error('ipBuff is required');
    }
    if (!_ip_js__WEBPACK_IMPORTED_MODULE_10__.isIP(ipString)) {
        throw new Error('invalid ip address');
    }
    return ipString;
}
function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
}
function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
    const buf = (0,uint8arrays_from_string__WEBPACK_IMPORTED_MODULE_8__.fromString)(str);
    const size = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encode(buf.length));
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([size, buf], size.length + buf.length);
}
function bytes2str(buf) {
    const size = uint8_varint__WEBPACK_IMPORTED_MODULE_6__.decode(buf);
    buf = buf.slice(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encodingLength(size));
    if (buf.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(buf);
}
function mh2bytes(hash) {
    let mh;
    if (hash[0] === 'Q' || hash[0] === '1') {
        mh = multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_5__.decode(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_2__.base58btc.decode(`z${hash}`)).bytes;
    }
    else {
        mh = multiformats_cid__WEBPACK_IMPORTED_MODULE_4__.CID.parse(hash).multihash.bytes;
    }
    // the address is a varint prefixed multihash string representation
    const size = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encode(mh.length));
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encode(mb.length));
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([size, mb], size.length + mb.length);
}
function bytes2mb(buf) {
    const size = uint8_varint__WEBPACK_IMPORTED_MODULE_6__.decode(buf);
    const hash = buf.slice(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encodingLength(size));
    if (hash.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return 'u' + (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(hash, 'base64url');
}
/**
 * Converts bytes to bas58btc string
 */
function bytes2mh(buf) {
    const size = uint8_varint__WEBPACK_IMPORTED_MODULE_6__.decode(buf);
    const address = buf.slice(uint8_varint__WEBPACK_IMPORTED_MODULE_6__.encodingLength(size));
    if (address.length !== size) {
        throw new Error('inconsistent lengths');
    }
    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(address, 'base58btc');
}
function onion2bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_1__.base32.decode('b' + addr[0]);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([buf, portBuf], buf.length + portBuf.length);
}
function onion32bytes(str) {
    const addr = str.split(':');
    if (addr.length !== 2) {
        throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    // onion addresses do not include the multibase prefix, add it before decoding
    const buf = multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_1__.base32.decode(`b${addr[0]}`);
    // onion port number
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
        throw new Error('Port number is not in range(1, 65536)');
    }
    const portBuf = port2bytes(port);
    return (0,uint8arrays_concat__WEBPACK_IMPORTED_MODULE_7__.concat)([buf, portBuf], buf.length + portBuf.length);
}
function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_9__.toString)(addrBytes, 'base32');
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
}
//# sourceMappingURL=convert.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiaddrFilter: () => (/* binding */ MultiaddrFilter)
/* harmony export */ });
/* harmony import */ var _convert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../convert.js */ "./node_modules/@multiformats/multiaddr/dist/src/convert.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");


/**
 * A utility class to determine if a Multiaddr contains another
 * multiaddr.
 *
 * This can be used with ipcidr ranges to determine if a given
 * multiaddr is in a ipcidr range.
 *
 * @example
 *
 * ```js
 * import { multiaddr, MultiaddrFilter } from '@multiformats/multiaddr'
 *
 * const range = multiaddr('/ip4/192.168.10.10/ipcidr/24')
 * const filter = new MultiaddrFilter(range)
 *
 * const input = multiaddr('/ip4/192.168.10.2/udp/60')
 * console.info(filter.contains(input)) // true
 * ```
 */
class MultiaddrFilter {
    multiaddr;
    netmask;
    constructor(input) {
        this.multiaddr = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.multiaddr)(input);
        this.netmask = (0,_convert_js__WEBPACK_IMPORTED_MODULE_0__.convertToIpNet)(this.multiaddr);
    }
    contains(input) {
        if (input == null)
            return false;
        const m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.multiaddr)(input);
        let ip;
        for (const [code, value] of m.stringTuples()) {
            if (code === 4 || code === 41) {
                ip = value;
                break;
            }
        }
        if (ip === undefined)
            return false;
        return this.netmask.contains(ip);
    }
}
//# sourceMappingURL=multiaddr-filter.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiaddrFilter: () => (/* reexport safe */ _filter_multiaddr_filter_js__WEBPACK_IMPORTED_MODULE_2__.MultiaddrFilter),
/* harmony export */   fromNodeAddress: () => (/* binding */ fromNodeAddress),
/* harmony export */   isMultiaddr: () => (/* binding */ isMultiaddr),
/* harmony export */   isName: () => (/* binding */ isName),
/* harmony export */   multiaddr: () => (/* binding */ multiaddr),
/* harmony export */   protocols: () => (/* reexport safe */ _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__.getProtocol),
/* harmony export */   resolvers: () => (/* binding */ resolvers)
/* harmony export */ });
/* harmony import */ var _multiaddr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./multiaddr.js */ "./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js");
/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocols-table.js */ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js");
/* harmony import */ var _filter_multiaddr_filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter/multiaddr-filter.js */ "./node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js");
/**
 * @packageDocumentation
 *
 * A standard way to represent addresses that
 *
 * - support any standard network protocol
 * - are self-describing
 * - have a binary packed format
 * - have a nice string representation
 * - encapsulate well
 *
 * @example
 *
 * ```TypeScript
 * import { multiaddr } from '@multiformats/multiaddr'
 * const addr =  multiaddr("/ip4/127.0.0.1/udp/1234")
 * // Multiaddr(/ip4/127.0.0.1/udp/1234)
 *
 * const addr = multiaddr("/ip4/127.0.0.1/udp/1234")
 * // Multiaddr(/ip4/127.0.0.1/udp/1234)
 *
 * addr.bytes
 * // <Uint8Array 04 7f 00 00 01 11 04 d2>
 *
 * addr.toString()
 * // '/ip4/127.0.0.1/udp/1234'
 *
 * addr.protos()
 * // [
 * //   {code: 4, name: 'ip4', size: 32},
 * //   {code: 273, name: 'udp', size: 16}
 * // ]
 *
 * // gives you an object that is friendly with what Node.js core modules expect for addresses
 * addr.nodeAddress()
 * // {
 * //   family: 4,
 * //   port: 1234,
 * //   address: "127.0.0.1"
 * // }
 *
 * addr.encapsulate('/sctp/5678')
 * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)
 * ```
 *
 * ## Resolving DNSADDR addresses
 *
 * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.
 *
 * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.
 *
 * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.
 *
 * @example Resolving DNSADDR Multiaddrs
 *
 * ```TypeScript
 * import { multiaddr, resolvers } from '@multiformats/multiaddr'
 * import { dnsaddr } from '@multiformats/multiaddr/resolvers'
 *
 * resolvers.set('dnsaddr', dnsaddr)
 *
 * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')
 *
 * // resolve with a 5s timeout
 * const resolved = await ma.resolve({
 *   signal: AbortSignal.timeout(5000)
 * })
 *
 * console.info(await ma.resolve(resolved)
 * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]
 * ```
 *
 * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs
 *
 * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.
 *
 * ```TypeScript
 * import { multiaddr } from '@multiformats/multiaddr'
 * import { dns } from '@multiformats/dns'
 * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'
 *
 * const resolver = dns({
 *   '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')
 * })
 *
 * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')
 * const resolved = await ma.resolve({
 *  dns: resolver
 * })
 *
 * console.info(resolved)
 * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]
 * ```
 */


/**
 * All configured {@link Resolver}s
 */
const resolvers = new Map();

/**
 * Creates a Multiaddr from a node-friendly address object
 *
 * @example
 * ```js
 * import { fromNodeAddress } from '@multiformats/multiaddr'
 *
 * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')
 * // Multiaddr(/ip4/127.0.0.1/tcp/4001)
 * ```
 */
function fromNodeAddress(addr, transport) {
    if (addr == null) {
        throw new Error('requires node address object');
    }
    if (transport == null) {
        throw new Error('requires transport protocol');
    }
    let ip;
    let host = addr.address;
    switch (addr.family) {
        case 4:
            ip = 'ip4';
            break;
        case 6:
            ip = 'ip6';
            if (host.includes('%')) {
                const parts = host.split('%');
                if (parts.length !== 2) {
                    throw Error('Multiple ip6 zones in multiaddr');
                }
                host = parts[0];
                const zone = parts[1];
                ip = `/ip6zone/${zone}/ip6`;
            }
            break;
        default:
            throw Error('Invalid addr family, should be 4 or 6.');
    }
    return new _multiaddr_js__WEBPACK_IMPORTED_MODULE_0__.Multiaddr('/' + [ip, host, transport, addr.port].join('/'));
}
/**
 * Returns if something is a {@link Multiaddr} that is a resolvable name
 *
 * @example
 *
 * ```js
 * import { isName, multiaddr } from '@multiformats/multiaddr'
 *
 * isName(multiaddr('/ip4/127.0.0.1'))
 * // false
 * isName(multiaddr('/dns/ipfs.io'))
 * // true
 * ```
 */
function isName(addr) {
    if (!isMultiaddr(addr)) {
        return false;
    }
    // if a part of the multiaddr is resolvable, then return true
    return addr.protos().some((proto) => proto.resolvable);
}
/**
 * Check if object is a {@link Multiaddr} instance
 *
 * @example
 *
 * ```js
 * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'
 *
 * isMultiaddr(5)
 * // false
 * isMultiaddr(multiaddr('/ip4/127.0.0.1'))
 * // true
 * ```
 */
function isMultiaddr(value) {
    return Boolean(value?.[_multiaddr_js__WEBPACK_IMPORTED_MODULE_0__.symbol]);
}
/**
 * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}
 *
 * @example
 * ```js
 * import { multiaddr } from '@libp2p/multiaddr'
 *
 * multiaddr('/ip4/127.0.0.1/tcp/4001')
 * // Multiaddr(/ip4/127.0.0.1/tcp/4001)
 * ```
 *
 * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)
 */
function multiaddr(addr) {
    return new _multiaddr_js__WEBPACK_IMPORTED_MODULE_0__.Multiaddr(addr);
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isIP: () => (/* reexport safe */ _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__.isIP),
/* harmony export */   isV4: () => (/* binding */ isV4),
/* harmony export */   isV6: () => (/* binding */ isV6),
/* harmony export */   toBytes: () => (/* binding */ toBytes),
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chainsafe/is-ip */ "./node_modules/@chainsafe/is-ip/lib/is-ip.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");



const isV4 = _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__.isIPv4;
const isV6 = _chainsafe_is_ip__WEBPACK_IMPORTED_MODULE_0__.isIPv6;
// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7
// but with buf/offset args removed because we don't use them
const toBytes = function (ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
        const bytes = new Uint8Array(offset + 4);
        ip.split(/\./g).forEach((byte) => {
            bytes[offset++] = parseInt(byte, 10) & 0xff;
        });
        return bytes;
    }
    if (isV6(ip)) {
        const sections = ip.split(':', 8);
        let i;
        for (i = 0; i < sections.length; i++) {
            const isv4 = isV4(sections[i]);
            let v4Buffer;
            if (isv4) {
                v4Buffer = toBytes(sections[i]);
                sections[i] = (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(v4Buffer.slice(0, 2), 'base16');
            }
            if (v4Buffer != null && ++i < 8) {
                sections.splice(i, 0, (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(v4Buffer.slice(2, 4), 'base16'));
            }
        }
        if (sections[0] === '') {
            while (sections.length < 8)
                sections.unshift('0');
        }
        else if (sections[sections.length - 1] === '') {
            while (sections.length < 8)
                sections.push('0');
        }
        else if (sections.length < 8) {
            for (i = 0; i < sections.length && sections[i] !== ''; i++)
                ;
            const argv = [i, 1];
            for (i = 9 - sections.length; i > 0; i--) {
                argv.push('0');
            }
            sections.splice.apply(sections, argv);
        }
        const bytes = new Uint8Array(offset + 16);
        for (i = 0; i < sections.length; i++) {
            const word = parseInt(sections[i], 16);
            bytes[offset++] = (word >> 8) & 0xff;
            bytes[offset++] = word & 0xff;
        }
        return bytes;
    }
    throw new Error('invalid ip address');
};
// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63
const toString = function (buf, offset = 0, length) {
    offset = ~~offset;
    length = length ?? (buf.length - offset);
    const view = new DataView(buf.buffer);
    if (length === 4) {
        const result = [];
        // IPv4
        for (let i = 0; i < length; i++) {
            result.push(buf[offset + i]);
        }
        return result.join('.');
    }
    if (length === 16) {
        const result = [];
        // IPv6
        for (let i = 0; i < length; i += 2) {
            result.push(view.getUint16(offset + i).toString(16));
        }
        return result.join(':')
            .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')
            .replace(/:{3,4}/, '::');
    }
    return '';
};
//# sourceMappingURL=ip.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js":
/*!********************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Multiaddr: () => (/* binding */ Multiaddr),
/* harmony export */   symbol: () => (/* binding */ symbol)
/* harmony export */ });
/* harmony import */ var _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @libp2p/interface */ "./node_modules/@libp2p/interface/dist/src/errors.js");
/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/bases/base58 */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats/cid */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js");
/* harmony import */ var uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uint8arrays/equals */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js");
/* harmony import */ var _codec_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./codec.js */ "./node_modules/@multiformats/multiaddr/dist/src/codec.js");
/* harmony import */ var _protocols_table_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./protocols-table.js */ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./index.js */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/**
 * @packageDocumentation
 *
 * An implementation of a Multiaddr in JavaScript
 *
 * @example
 *
 * ```js
 * import { multiaddr } from '@multiformats/multiaddr'
 *
 * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')
 * ```
 */








const inspect = Symbol.for('nodejs.util.inspect.custom');
const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');
const DNS_CODES = [
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns').code,
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns4').code,
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns6').code,
    (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dnsaddr').code
];
/**
 * Creates a {@link Multiaddr} from a {@link MultiaddrInput}
 */
class Multiaddr {
    bytes;
    #string;
    #tuples;
    #stringTuples;
    #path;
    [symbol] = true;
    constructor(addr) {
        // default
        if (addr == null) {
            addr = '';
        }
        let parts;
        if (addr instanceof Uint8Array) {
            parts = (0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.bytesToMultiaddrParts)(addr);
        }
        else if (typeof addr === 'string') {
            if (addr.length > 0 && addr.charAt(0) !== '/') {
                throw new Error(`multiaddr "${addr}" must start with a "/"`);
            }
            parts = (0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.stringToMultiaddrParts)(addr);
        }
        else if ((0,_index_js__WEBPACK_IMPORTED_MODULE_6__.isMultiaddr)(addr)) { // Multiaddr
            parts = (0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.bytesToMultiaddrParts)(addr.bytes);
        }
        else {
            throw new Error('addr must be a string, Buffer, or another Multiaddr');
        }
        this.bytes = parts.bytes;
        this.#string = parts.string;
        this.#tuples = parts.tuples;
        this.#stringTuples = parts.stringTuples;
        this.#path = parts.path;
    }
    toString() {
        return this.#string;
    }
    toJSON() {
        return this.toString();
    }
    toOptions() {
        let family;
        let transport;
        let host;
        let port;
        let zone = '';
        const tcp = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('tcp');
        const udp = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('udp');
        const ip4 = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('ip4');
        const ip6 = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('ip6');
        const dns6 = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('dns6');
        const ip6zone = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)('ip6zone');
        for (const [code, value] of this.stringTuples()) {
            if (code === ip6zone.code) {
                zone = `%${value ?? ''}`;
            }
            // default to https when protocol & port are omitted from DNS addrs
            if (DNS_CODES.includes(code)) {
                transport = tcp.name;
                port = 443;
                host = `${value ?? ''}${zone}`;
                family = code === dns6.code ? 6 : 4;
            }
            if (code === tcp.code || code === udp.code) {
                transport = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code).name;
                port = parseInt(value ?? '');
            }
            if (code === ip4.code || code === ip6.code) {
                transport = (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code).name;
                host = `${value ?? ''}${zone}`;
                family = code === ip6.code ? 6 : 4;
            }
        }
        if (family == null || transport == null || host == null || port == null) {
            throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
        }
        const opts = {
            family,
            host,
            transport,
            port
        };
        return opts;
    }
    protos() {
        return this.#tuples.map(([code]) => Object.assign({}, (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code)));
    }
    protoCodes() {
        return this.#tuples.map(([code]) => code);
    }
    protoNames() {
        return this.#tuples.map(([code]) => (0,_protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.getProtocol)(code).name);
    }
    tuples() {
        return this.#tuples;
    }
    stringTuples() {
        return this.#stringTuples;
    }
    encapsulate(addr) {
        addr = new Multiaddr(addr);
        return new Multiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
        }
        return new Multiaddr(s.slice(0, i));
    }
    decapsulateCode(code) {
        const tuples = this.tuples();
        for (let i = tuples.length - 1; i >= 0; i--) {
            if (tuples[i][0] === code) {
                return new Multiaddr((0,_codec_js__WEBPACK_IMPORTED_MODULE_4__.tuplesToBytes)(tuples.slice(0, i)));
            }
        }
        return this;
    }
    getPeerId() {
        try {
            let tuples = [];
            this.stringTuples().forEach(([code, name]) => {
                if (code === _protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.names.p2p.code) {
                    tuples.push([code, name]);
                }
                // if this is a p2p-circuit address, return the target peer id if present
                // not the peer id of the relay
                if (code === _protocols_table_js__WEBPACK_IMPORTED_MODULE_5__.names['p2p-circuit'].code) {
                    tuples = [];
                }
            });
            // Get the last ipfs tuple ['p2p', 'peerid string']
            const tuple = tuples.pop();
            if (tuple?.[1] != null) {
                const peerIdStr = tuple[1];
                // peer id is base58btc encoded string but not multibase encoded so add the `z`
                // prefix so we can validate that it is correctly encoded
                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {
                    return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_0__.base58btc.decode(`z${peerIdStr}`), 'base58btc');
                }
                // try to parse peer id as CID
                return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_3__.toString)(multiformats_cid__WEBPACK_IMPORTED_MODULE_1__.CID.parse(peerIdStr).multihash.bytes, 'base58btc');
            }
            return null;
        }
        catch (e) {
            return null;
        }
    }
    getPath() {
        return this.#path;
    }
    equals(addr) {
        return (0,uint8arrays_equals__WEBPACK_IMPORTED_MODULE_2__.equals)(this.bytes, addr.bytes);
    }
    async resolve(options) {
        const resolvableProto = this.protos().find((p) => p.resolvable);
        // Multiaddr is not resolvable?
        if (resolvableProto == null) {
            return [this];
        }
        const resolver = _index_js__WEBPACK_IMPORTED_MODULE_6__.resolvers.get(resolvableProto.name);
        if (resolver == null) {
            throw new _libp2p_interface__WEBPACK_IMPORTED_MODULE_7__.CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');
        }
        const result = await resolver(this, options);
        return result.map(str => (0,_index_js__WEBPACK_IMPORTED_MODULE_6__.multiaddr)(str));
    }
    nodeAddress() {
        const options = this.toOptions();
        if (options.transport !== 'tcp' && options.transport !== 'udp') {
            throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
        }
        return {
            family: options.family,
            address: options.host,
            port: options.port
        };
    }
    isThinWaistAddress(addr) {
        const protos = (addr ?? this).protos();
        if (protos.length !== 2) {
            return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
            return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
            return false;
        }
        return true;
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */
    [inspect]() {
        return `Multiaddr(${this.#string})`;
    }
}
//# sourceMappingURL=multiaddr.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   codes: () => (/* binding */ codes),
/* harmony export */   createProtocol: () => (/* binding */ createProtocol),
/* harmony export */   getProtocol: () => (/* binding */ getProtocol),
/* harmony export */   names: () => (/* binding */ names),
/* harmony export */   table: () => (/* binding */ table)
/* harmony export */ });
const V = -1;
const names = {};
const codes = {};
const table = [
    [4, 32, 'ip4'],
    [6, 16, 'tcp'],
    [33, 16, 'dccp'],
    [41, 128, 'ip6'],
    [42, V, 'ip6zone'],
    [43, 8, 'ipcidr'],
    [53, V, 'dns', true],
    [54, V, 'dns4', true],
    [55, V, 'dns6', true],
    [56, V, 'dnsaddr', true],
    [132, 16, 'sctp'],
    [273, 16, 'udp'],
    [275, 0, 'p2p-webrtc-star'],
    [276, 0, 'p2p-webrtc-direct'],
    [277, 0, 'p2p-stardust'],
    [280, 0, 'webrtc-direct'],
    [281, 0, 'webrtc'],
    [290, 0, 'p2p-circuit'],
    [301, 0, 'udt'],
    [302, 0, 'utp'],
    [400, V, 'unix', false, true],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [421, V, 'ipfs'],
    // `p2p` is the preferred name for 421, and is now the default
    [421, V, 'p2p'],
    [443, 0, 'https'],
    [444, 96, 'onion'],
    [445, 296, 'onion3'],
    [446, V, 'garlic64'],
    [448, 0, 'tls'],
    [449, V, 'sni'],
    [460, 0, 'quic'],
    [461, 0, 'quic-v1'],
    [465, 0, 'webtransport'],
    [466, V, 'certhash'],
    [477, 0, 'ws'],
    [478, 0, 'wss'],
    [479, 0, 'p2p-websocket-star'],
    [480, 0, 'http'],
    [481, V, 'http-path'],
    [777, V, 'memory']
];
// populate tables
table.forEach(row => {
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
});
function createProtocol(code, size, name, resolvable, path) {
    return {
        code,
        size,
        name,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
    };
}
/**
 * For the passed proto string or number, return a {@link Protocol}
 *
 * @example
 *
 * ```js
 * import { protocol } from '@multiformats/multiaddr'
 *
 * console.info(protocol(4))
 * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }
 * ```
 */
function getProtocol(proto) {
    if (typeof proto === 'number') {
        if (codes[proto] != null) {
            return codes[proto];
        }
        throw new Error(`no protocol with code: ${proto}`);
    }
    else if (typeof proto === 'string') {
        if (names[proto] != null) {
            return names[proto];
        }
        throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
}
//# sourceMappingURL=protocols-table.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Codec: () => (/* binding */ Codec),
/* harmony export */   baseX: () => (/* binding */ baseX),
/* harmony export */   from: () => (/* binding */ from),
/* harmony export */   or: () => (/* binding */ or),
/* harmony export */   rfc4648: () => (/* binding */ rfc4648)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vendor/base-x.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js");


/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 */
class Encoder {
    name;
    prefix;
    baseEncode;
    constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        }
        else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 */
class Decoder {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        /* c8 ignore next 3 */
        if (prefix.codePointAt(0) === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        }
        else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    decoders;
    constructor(decoders) {
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) {
            return decoder.decode(input);
        }
        else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
function or(left, right) {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return new ComposedDecoder({
        ...(left.decoders ?? { [left.prefix]: left }),
        ...(right.decoders ?? { [right.prefix]: right })
    });
}
class Codec {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
function from({ name, prefix, encode, decode }) {
    return new Codec(name, prefix, encode, decode);
}
function baseX({ name, prefix, alphabet }) {
    const { encode, decode } = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__["default"])(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(decode(text))
    });
}
function decode(string, alphabet, bitsPerChar, name) {
    // Build the character lookup table:
    const codes = {};
    for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
    }
    // Count the padding bytes:
    let end = string.length;
    while (string[end - 1] === '=') {
        --end;
    }
    // Allocate the output:
    const out = new Uint8Array((end * bitsPerChar / 8) | 0);
    // Parse the data:
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    let written = 0; // Next byte to write
    for (let i = 0; i < end; ++i) {
        // Read one character from the string:
        const value = codes[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        // Append the bits to the buffer:
        buffer = (buffer << bitsPerChar) | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & (buffer >> bits);
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
}
function encode(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    for (let i = 0; i < data.length; ++i) {
        // Slurp data into the buffer:
        buffer = (buffer << 8) | data[i];
        bits += 8;
        // Write out as much as we can:
        while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet[mask & (buffer >> bits)];
        }
    }
    // Partial character:
    if (bits !== 0) {
        out += alphabet[mask & (buffer << (bitsPerChar - bits))];
    }
    // Add padding characters until we hit a byte boundary:
    if (pad) {
        while (((out.length * bitsPerChar) & 7) !== 0) {
            out += '=';
        }
    }
    return out;
}
/**
 * RFC4648 Factory
 */
function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    return from({
        prefix,
        name,
        encode(input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode(input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
}
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base10: () => (/* binding */ base10)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base10 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789'
});
//# sourceMappingURL=base10.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base16: () => (/* binding */ base16),
/* harmony export */   base16upper: () => (/* binding */ base16upper)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base16 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4
});
const base16upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4
});
//# sourceMappingURL=base16.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base2: () => (/* binding */ base2)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base2 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1
});
//# sourceMappingURL=base2.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base256emoji: () => (/* binding */ base256emoji)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const alphabet = Array.from('');
const alphabetBytesToChars = (alphabet.reduce((p, c, i) => { p[i] = c; return p; }, ([])));
const alphabetCharsToBytes = (alphabet.reduce((p, c, i) => { p[c.codePointAt(0)] = i; return p; }, ([])));
function encode(data) {
    return data.reduce((p, c) => {
        p += alphabetBytesToChars[c];
        return p;
    }, '');
}
function decode(str) {
    const byts = [];
    for (const char of str) {
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === undefined) {
            throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({
    prefix: '',
    name: 'base256emoji',
    encode,
    decode
});
//# sourceMappingURL=base256emoji.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base32: () => (/* binding */ base32),
/* harmony export */   base32hex: () => (/* binding */ base32hex),
/* harmony export */   base32hexpad: () => (/* binding */ base32hexpad),
/* harmony export */   base32hexpadupper: () => (/* binding */ base32hexpadupper),
/* harmony export */   base32hexupper: () => (/* binding */ base32hexupper),
/* harmony export */   base32pad: () => (/* binding */ base32pad),
/* harmony export */   base32padupper: () => (/* binding */ base32padupper),
/* harmony export */   base32upper: () => (/* binding */ base32upper),
/* harmony export */   base32z: () => (/* binding */ base32z)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
});
const base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
});
const base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
});
const base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
});
const base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
});
const base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
});
const base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
});
const base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
});
const base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
});
//# sourceMappingURL=base32.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base36: () => (/* binding */ base36),
/* harmony export */   base36upper: () => (/* binding */ base36upper)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base36 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});
//# sourceMappingURL=base36.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base58btc: () => (/* binding */ base58btc),
/* harmony export */   base58flickr: () => (/* binding */ base58flickr)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});
//# sourceMappingURL=base58.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64: () => (/* binding */ base64),
/* harmony export */   base64pad: () => (/* binding */ base64pad),
/* harmony export */   base64url: () => (/* binding */ base64url),
/* harmony export */   base64urlpad: () => (/* binding */ base64urlpad)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
});
const base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
});
const base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
});
const base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
});
//# sourceMappingURL=base64.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base8: () => (/* binding */ base8)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");

const base8 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3
});
//# sourceMappingURL=base8.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js");


const identity = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.from)({
    prefix: '\x00',
    name: 'identity',
    encode: (buf) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.toString)(buf),
    decode: (str) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromString)(str)
});
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/interface.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/interface.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// Base encoders / decoders just base encode / decode between binary and
// textual representation. They are unaware of multibase.

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CID: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.CID),
/* harmony export */   bases: () => (/* binding */ bases),
/* harmony export */   bytes: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.bytes),
/* harmony export */   codecs: () => (/* binding */ codecs),
/* harmony export */   digest: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.digest),
/* harmony export */   hasher: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.hasher),
/* harmony export */   hashes: () => (/* binding */ hashes),
/* harmony export */   varint: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.varint)
/* harmony export */ });
/* harmony import */ var _bases_base10_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/base10.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js");
/* harmony import */ var _bases_base16_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base16.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js");
/* harmony import */ var _bases_base2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base2.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js");
/* harmony import */ var _bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base256emoji.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js");
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js");
/* harmony import */ var _bases_base36_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bases/base36.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js");
/* harmony import */ var _bases_base64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bases/base64.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js");
/* harmony import */ var _bases_base8_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bases/base8.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js");
/* harmony import */ var _bases_identity_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bases/identity.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js");
/* harmony import */ var _codecs_json_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./codecs/json.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js");
/* harmony import */ var _codecs_raw_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./codecs/raw.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/raw.js");
/* harmony import */ var _hashes_identity_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./hashes/identity.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js");
/* harmony import */ var _hashes_sha2_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./hashes/sha2.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./index.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/index.js");















const bases = { ..._bases_identity_js__WEBPACK_IMPORTED_MODULE_9__, ..._bases_base2_js__WEBPACK_IMPORTED_MODULE_2__, ..._bases_base8_js__WEBPACK_IMPORTED_MODULE_8__, ..._bases_base10_js__WEBPACK_IMPORTED_MODULE_0__, ..._bases_base16_js__WEBPACK_IMPORTED_MODULE_1__, ..._bases_base32_js__WEBPACK_IMPORTED_MODULE_4__, ..._bases_base36_js__WEBPACK_IMPORTED_MODULE_5__, ..._bases_base58_js__WEBPACK_IMPORTED_MODULE_6__, ..._bases_base64_js__WEBPACK_IMPORTED_MODULE_7__, ..._bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_3__ };
const hashes = { ..._hashes_sha2_js__WEBPACK_IMPORTED_MODULE_13__, ..._hashes_identity_js__WEBPACK_IMPORTED_MODULE_12__ };
const codecs = { raw: _codecs_raw_js__WEBPACK_IMPORTED_MODULE_11__, json: _codecs_json_js__WEBPACK_IMPORTED_MODULE_10__ };

//# sourceMappingURL=basics.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/block/interface.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/block/interface.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coerce: () => (/* binding */ coerce),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   fromHex: () => (/* binding */ fromHex),
/* harmony export */   fromString: () => (/* binding */ fromString),
/* harmony export */   isBinary: () => (/* binding */ isBinary),
/* harmony export */   toHex: () => (/* binding */ toHex),
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
const empty = new Uint8Array(0);
function toHex(d) {
    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');
}
function fromHex(hex) {
    const hexes = hex.match(/../g);
    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;
}
function equals(aa, bb) {
    if (aa === bb)
        return true;
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
}
function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')
        return o;
    if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error('Unknown type, must be binary type');
}
function isBinary(o) {
    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString(str) {
    return new TextEncoder().encode(str);
}
function toString(b) {
    return new TextDecoder().decode(b);
}
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CID: () => (/* binding */ CID),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   fromJSON: () => (/* binding */ fromJSON),
/* harmony export */   toJSON: () => (/* binding */ toJSON)
/* harmony export */ });
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js");
/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./link/interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/link/interface.js");





// This way TS will also expose all the types from module

function format(link, base) {
    const { bytes, version } = link;
    switch (version) {
        case 0:
            return toStringV0(bytes, baseCache(link), base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.encoder);
        default:
            return toStringV1(bytes, baseCache(link), (base ?? _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.encoder));
    }
}
function toJSON(link) {
    return {
        '/': format(link)
    };
}
function fromJSON(json) {
    return CID.parse(json['/']);
}
const cache = new WeakMap();
function baseCache(cid) {
    const baseCache = cache.get(cid);
    if (baseCache == null) {
        const baseCache = new Map();
        cache.set(cid, baseCache);
        return baseCache;
    }
    return baseCache;
}
class CID {
    code;
    version;
    multihash;
    bytes;
    '/';
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version, code, multihash, bytes) {
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        // flag to serializers that this is a CID and
        // should be treated specially
        this['/'] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
        return this;
    }
    // ArrayBufferView
    get byteOffset() {
        return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
        return this.bytes.byteLength;
    }
    toV0() {
        switch (this.version) {
            case 0: {
                return this;
            }
            case 1: {
                const { code, multihash } = this;
                if (code !== DAG_PB_CODE) {
                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');
                }
                // sha2-256
                if (multihash.code !== SHA_256_CODE) {
                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
                }
                return (CID.createV0(multihash));
            }
            default: {
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
        }
    }
    toV1() {
        switch (this.version) {
            case 0: {
                const { code, digest } = this.multihash;
                const multihash = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.create(code, digest);
                return (CID.createV1(this.code, multihash));
            }
            case 1: {
                return this;
            }
            default: {
                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
            }
        }
    }
    equals(other) {
        return CID.equals(this, other);
    }
    static equals(self, other) {
        const unknown = other;
        return (unknown != null &&
            self.code === unknown.code &&
            self.version === unknown.version &&
            _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.equals(self.multihash, unknown.multihash));
    }
    toString(base) {
        return format(this, base);
    }
    toJSON() {
        return { '/': format(this) };
    }
    link() {
        return this;
    }
    [Symbol.toStringTag] = 'CID';
    // Legacy
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
        if (input == null) {
            return null;
        }
        const value = input;
        if (value instanceof CID) {
            // If value is instance of CID then we're all set.
            return value;
        }
        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {
            // If value isn't instance of this CID class but `this.asCID === this` or
            // `value['/'] === value.bytes` is true it is CID instance coming from a
            // different implementation (diff version or duplicate). In that case we
            // rebase it to this `CID` implementation so caller is guaranteed to get
            // instance with expected API.
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));
        }
        else if (value[cidSymbol] === true) {
            // If value is a CID from older implementation that used to be tagged via
            // symbol we still rebase it to the this `CID` implementation by
            // delegating that to a constructor.
            const { version, multihash, code } = value;
            const digest = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.decode(multihash);
            return CID.create(version, code, digest);
        }
        else {
            // Otherwise value is not a CID (or an incompatible version of it) in
            // which case we return `null`.
            return null;
        }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version, code, digest) {
        if (typeof code !== 'number') {
            throw new Error('String codecs are no longer supported');
        }
        if (!(digest.bytes instanceof Uint8Array)) {
            throw new Error('Invalid digest');
        }
        switch (version) {
            case 0: {
                if (code !== DAG_PB_CODE) {
                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                }
                else {
                    return new CID(version, code, digest, digest.bytes);
                }
            }
            case 1: {
                const bytes = encodeCID(version, code, digest.bytes);
                return new CID(version, code, digest, bytes);
            }
            default: {
                throw new Error('Invalid version');
            }
        }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length !== 0) {
            throw new Error('Incorrect length');
        }
        return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error('Incorrect length');
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0
            ? CID.createV0(digest)
            : CID.createV1(specs.codec, digest);
        return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
            const [i, length] = _varint_js__WEBPACK_IMPORTED_MODULE_4__.decode(initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            // CIDv0
            version = 0;
            offset = 0;
        }
        else {
            codec = next();
        }
        if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = next(); // multihash code
        const digestSize = next(); // multihash length
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return { version, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        if (cid.version === 0 && source[0] !== 'Q') {
            throw Error('Version 0 CID string must not include multibase prefix');
        }
        // Cache string representation to avoid computing it on `this.toString()`
        baseCache(cid).set(prefix, source);
        return cid;
    }
}
function parseCIDtoBytes(source, base) {
    switch (source[0]) {
        // CIDv0 is parsed differently
        case 'Q': {
            const decoder = base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc;
            return [
                _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix,
                decoder.decode(`${_bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix}${source}`)
            ];
        }
        case _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix: {
            const decoder = base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc;
            return [_bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix, decoder.decode(source)];
        }
        case _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.prefix: {
            const decoder = base ?? _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32;
            return [_bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.prefix, decoder.decode(source)];
        }
        default: {
            if (base == null) {
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
            }
            return [source[0], base.decode(source)];
        }
    }
}
function toStringV0(bytes, cache, base) {
    const { prefix } = base;
    if (prefix !== _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    }
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    }
    else {
        return cid;
    }
}
function toStringV1(bytes, cache, base) {
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    }
    else {
        return cid;
    }
}
const DAG_PB_CODE = 0x70;
const SHA_256_CODE = 0x12;
function encodeCID(version, code, multihash) {
    const codeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodingLength(version);
    const hashOffset = codeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodeTo(version, bytes, 0);
    _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
}
const cidSymbol = Symbol.for('@ipld/js-cid/CID');
//# sourceMappingURL=cid.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/interface.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/interface.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   name: () => (/* binding */ name)
/* harmony export */ });
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 0x0200;
function encode(node) {
    return textEncoder.encode(JSON.stringify(node));
}
function decode(data) {
    return JSON.parse(textDecoder.decode(data));
}
//# sourceMappingURL=json.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/raw.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/raw.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   name: () => (/* binding */ name)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js");

const name = 'raw';
const code = 0x55;
function encode(node) {
    return (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(node);
}
function decode(data) {
    return (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(data);
}
//# sourceMappingURL=raw.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Digest: () => (/* binding */ Digest),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   equals: () => (/* binding */ equals)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js");


/**
 * Creates a multihash digest.
 */
function create(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code);
    const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0);
    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
}
/**
 * Turns bytes representation of multihash digest into an instance.
 */
function decode(multihash) {
    const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash);
    const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes);
    const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
        throw new Error('Incorrect length');
    }
    return new Digest(code, size, digest, bytes);
}
function equals(a, b) {
    if (a === b) {
        return true;
    }
    else {
        const data = b;
        return (a.code === data.code &&
            a.size === data.size &&
            data.bytes instanceof Uint8Array &&
            (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, data.bytes));
    }
}
/**
 * Represents a multihash digest which carries information about the
 * hashing algorithm and an actual hash digest.
 */
class Digest {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code, size, digest, bytes) {
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}
//# sourceMappingURL=digest.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hasher: () => (/* binding */ Hasher),
/* harmony export */   from: () => (/* binding */ from)
/* harmony export */ });
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js");

function from({ name, code, encode }) {
    return new Hasher(name, code, encode);
}
/**
 * Hasher represents a hashing algorithm implementation that produces as
 * `MultihashDigest`.
 */
class Hasher {
    name;
    code;
    encode;
    constructor(name, code, encode) {
        this.name = name;
        this.code = code;
        this.encode = encode;
    }
    digest(input) {
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array
                ? _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, result)
                /* c8 ignore next 1 */
                : result.then(digest => _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, digest));
        }
        else {
            throw Error('Unknown type, must be binary type');
            /* c8 ignore next 1 */
        }
    }
}
//# sourceMappingURL=hasher.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js");


const code = 0x0;
const name = 'identity';
const encode = _bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce;
function digest(input) {
    return _digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, encode(input));
}
const identity = { code, name, encode, digest };
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/interface.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/interface.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// # Multihash

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sha256: () => (/* binding */ sha256),
/* harmony export */   sha512: () => (/* binding */ sha512)
/* harmony export */ });
/* harmony import */ var _hasher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasher.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js");
/* global crypto */

function sha(name) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name, data));
}
const sha256 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_0__.from)({
    name: 'sha2-256',
    code: 0x12,
    encode: sha('SHA-256')
});
const sha512 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_0__.from)({
    name: 'sha2-512',
    code: 0x13,
    encode: sha('SHA-512')
});
//# sourceMappingURL=sha2-browser.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CID: () => (/* reexport safe */ _cid_js__WEBPACK_IMPORTED_MODULE_1__.CID),
/* harmony export */   bytes: () => (/* reexport module object */ _bytes_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   digest: () => (/* reexport module object */ _hashes_digest_js__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   hasher: () => (/* reexport module object */ _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   varint: () => (/* reexport module object */ _varint_js__WEBPACK_IMPORTED_MODULE_4__)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _cid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cid.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js");
/* harmony import */ var _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/hasher.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js");
/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/interface.js");
/**
 * @packageDocumentation
 *
 * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.
 *
 * This library provides implementations for most basics and many others can be found in linked repositories.
 *
 * ```TypeScript
 * import { CID } from 'multiformats/cid'
 * import * as json from 'multiformats/codecs/json'
 * import { sha256 } from 'multiformats/hashes/sha2'
 *
 * const bytes = json.encode({ hello: 'world' })
 *
 * const hash = await sha256.digest(bytes)
 * const cid = CID.create(1, json.code, hash)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Creating Blocks
 *
 * ```TypeScript
 * import * as Block from 'multiformats/block'
 * import * as codec from '@ipld/dag-cbor'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * const value = { hello: 'world' }
 *
 * // encode a block
 * let block = await Block.encode({ value, codec, hasher })
 *
 * block.value // { hello: 'world' }
 * block.bytes // Uint8Array
 * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec
 *
 * // you can also decode blocks from their binary state
 * block = await Block.decode({ bytes: block.bytes, codec, hasher })
 *
 * // if you have the cid you can also verify the hash on decode
 * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })
 * ```
 *
 * ## Multibase Encoders / Decoders / Codecs
 *
 * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:
 *
 * ```TypeScript
 * import { base64 } from "multiformats/bases/base64"
 * cid.toString(base64.encoder)
 * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'
 * ```
 *
 * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:
 *
 * ```TypeScript
 * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * Dual of multibase encoder & decoder is defined as multibase codec and it exposes
 * them as `encoder` and `decoder` properties. For added convenience codecs also
 * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be
 * used as either or both:
 *
 * ```TypeScript
 * cid.toString(base64)
 * CID.parse(cid.toString(base64), base64)
 * ```
 *
 * **Note:** CID implementation comes bundled with `base32` and `base58btc`
 * multibase codecs so that CIDs can be base serialized to (version specific)
 * default base encoding and parsed without having to supply base encoders/decoders:
 *
 * ```TypeScript
 * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')
 * v1.toString()
 * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'
 *
 * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')
 * v0.toString()
 * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'
 * v0.toV1().toString()
 * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'
 * ```
 *
 * ## Multicodec Encoders / Decoders / Codecs
 *
 * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).
 * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.
 * Here is an example implementation of JSON `BlockCodec`.
 *
 * ```TypeScript
 * export const { name, code, encode, decode } = {
 *   name: 'json',
 *   code: 0x0200,
 *   encode: json => new TextEncoder().encode(JSON.stringify(json)),
 *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))
 * }
 * ```
 *
 * ## Multihash Hashers
 *
 * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:
 *
 * ```TypeScript
 * import * as hasher from 'multiformats/hashes/hasher'
 *
 * const sha256 = hasher.from({
 *   // As per multiformats table
 *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9
 *   name: 'sha2-256',
 *   code: 0x12,
 *
 *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())
 * })
 *
 * const hash = await sha256.digest(json.encode({ hello: 'world' }))
 * CID.create(1, json.code, hash)
 *
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Traversal
 *
 * This library contains higher-order functions for traversing graphs of data easily.
 *
 * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.
 *
 * ```TypeScript
 * import { walk } from 'multiformats/traversal'
 * import * as Block from 'multiformats/block'
 * import * as codec from 'multiformats/codecs/json'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * // build a DAG (a single block for this simple example)
 * const value = { hello: 'world' }
 * const block = await Block.encode({ value, codec, hasher })
 * const { cid } = block
 * console.log(cid)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 *
 * // create a loader function that also collects CIDs of blocks in
 * // their traversal order
 * const load = (cid, blocks) => async (cid) => {
 *   // fetch a block using its cid
 *   // e.g.: const block = await fetchBlockByCID(cid)
 *   blocks.push(cid)
 *   return block
 * }
 *
 * // collect blocks in this DAG starting from the root `cid`
 * const blocks = []
 * await walk({ cid, load: load(cid, blocks) })
 *
 * console.log(blocks)
 * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]
 * ```
 *
 * ## Legacy interface
 *
 * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an
 * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.
 *
 * ## Implementations
 *
 * By default, no base encodings (other than base32 & base58btc), hash functions,
 * or codec implementations are exposed by `multiformats`, you need to
 * import the ones you need yourself.
 *
 * ### Multibase codecs
 *
 * | bases                                                         | import                      | repo                                                                                              |
 * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |
 * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 *
 * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.
 *
 * ### Multihash hashers
 *
 * | hashes                                                                                                                          | import                         | repo                                                                                                               |
 * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |
 * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |
 * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |
 * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |
 * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |
 * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |
 *
 * ### IPLD codecs (multicodec)
 *
 * | codec      | import                     | repo                                                                                                   |
 * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |
 * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |
 * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |
 * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |
 * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |
 */





// This way TS will also expose all the types from module


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/interface.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/interface.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bases_interface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/interface.js");
/* harmony import */ var _hashes_interface_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes/interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/interface.js");
/* harmony import */ var _codecs_interface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./codecs/interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/interface.js");
/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./link/interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/link/interface.js");
/* harmony import */ var _block_interface_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./block/interface.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/block/interface.js");





//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/link/interface.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/link/interface.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */
/* eslint-disable no-use-before-define */

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encodeTo: () => (/* binding */ encodeTo),
/* harmony export */   encodingLength: () => (/* binding */ encodingLength)
/* harmony export */ });
/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/varint.js */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/varint.js");

function decode(data, offset = 0) {
    const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].decode(data, offset);
    return [code, _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].decode.bytes];
}
function encodeTo(int, target, offset = 0) {
    _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].encode(int, target, offset);
    return target;
}
function encodingLength(int) {
    return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].encodingLength(int);
}
//# sourceMappingURL=varint.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable */
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
/**
 * @param {string} ALPHABET
 * @param {any} name
 */
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    /**
     * @param {any[] | Iterable<number>} source
     */
    function encode(source) {
        // @ts-ignore
        if (source instanceof Uint8Array)
            ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        }
        else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while (pbegin !== pend) {
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
                carry += (256 * b58[it1]) >>> 0;
                b58[it1] = (carry % BASE) >>> 0;
                carry = (carry / BASE) >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
            it2++;
        }
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    /**
     * @param {string | string[]} source
     */
    function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        // Skip leading spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
        var b256 = new Uint8Array(size);
        // Process the characters.
        while (source[psz]) {
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) {
                return;
            }
            var i = 0;
            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
                carry += (BASE * b256[it3]) >>> 0;
                b256[it3] = (carry % 256) >>> 0;
                carry = (carry / 256) >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        // Skip trailing spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while (it4 !== size) {
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    /**
     * @param {string | string[]} string
     */
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp__multiformats_scope_baseX);
//# sourceMappingURL=base-x.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/varint.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/varint.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable */
var encode_1 = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
/**
 * @param {number} num
 * @param {number[]} out
 * @param {number} offset
 */
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
        out[offset++] = (num & 0xFF) | MSB;
        num /= 128;
    }
    while (num & MSBALL) {
        out[offset++] = (num & 0xFF) | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    // @ts-ignore
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 0x80, REST$1 = 0x7F;
/**
 * @param {string | any[]} buf
 * @param {number} offset
 */
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            // @ts-ignore
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28
            ? (b & REST$1) << shift
            : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    } while (b >= MSB$1);
    // @ts-ignore
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function (/** @type {number} */ value) {
    return (value < N1 ? 1
        : value < N2 ? 2
            : value < N3 ? 3
                : value < N4 ? 4
                    : value < N5 ? 5
                        : value < N6 ? 6
                            : value < N7 ? 7
                                : value < N8 ? 8
                                    : value < N9 ? 9
                                        : 10);
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp_varint);
//# sourceMappingURL=varint.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alloc: () => (/* binding */ alloc),
/* harmony export */   allocUnsafe: () => (/* binding */ allocUnsafe)
/* harmony export */ });
/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */
function alloc(size = 0) {
    return new Uint8Array(size);
}
/**
 * Where possible returns a Uint8Array of the requested size that references
 * uninitialized memory. Only use if you are certain you will immediately
 * overwrite every value in the returned `Uint8Array`.
 */
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
}
//# sourceMappingURL=alloc.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concat: () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _alloc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! #alloc */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js");
/* harmony import */ var _util_as_uint8array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! #util/as-uint8array */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js");


/**
 * Returns a new Uint8Array created by concatenating the passed Uint8Arrays
 */
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = (0,_alloc__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(length);
    let offset = 0;
    for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0,_util_as_uint8array__WEBPACK_IMPORTED_MODULE_1__.asUint8Array)(output);
}
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   equals: () => (/* binding */ equals)
/* harmony export */ });
/**
 * Returns true if the two passed Uint8Arrays have the same content
 */
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=equals.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fromString: () => (/* binding */ fromString)
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js");

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */
function fromString(string, encoding = 'utf8') {
    const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
}
//# sourceMappingURL=from-string.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js");

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */
function toString(array, encoding = 'utf8') {
    const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
}
//# sourceMappingURL=to-string.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/as-uint8array.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asUint8Array: () => (/* binding */ asUint8Array)
/* harmony export */ });
/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */
function asUint8Array(buf) {
    return buf;
}
//# sourceMappingURL=as-uint8array.js.map

/***/ }),

/***/ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/basics */ "./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js");
/* harmony import */ var _alloc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! #alloc */ "./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js");


function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf) => {
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf) => {
    let string = 'a';
    for (let i = 0; i < buf.length; i++) {
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str) => {
    str = str.substring(1);
    const buf = (0,_alloc__WEBPACK_IMPORTED_MODULE_1__.allocUnsafe)(str.length);
    for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BASES);
//# sourceMappingURL=bases.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/dist/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/is-ipfs/dist/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base32cid: () => (/* binding */ base32cid),
/* harmony export */   cid: () => (/* binding */ isCID),
/* harmony export */   cidPath: () => (/* binding */ cidPath),
/* harmony export */   ipfsPath: () => (/* binding */ ipfsPath),
/* harmony export */   ipfsSubdomain: () => (/* binding */ ipfsSubdomain),
/* harmony export */   ipfsUrl: () => (/* binding */ ipfsUrl),
/* harmony export */   ipnsPath: () => (/* binding */ ipnsPath),
/* harmony export */   ipnsSubdomain: () => (/* binding */ ipnsSubdomain),
/* harmony export */   ipnsUrl: () => (/* binding */ ipnsUrl),
/* harmony export */   multiaddr: () => (/* binding */ isMultiaddr),
/* harmony export */   multihash: () => (/* binding */ isMultihash),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathGatewayPattern: () => (/* binding */ pathGatewayPattern),
/* harmony export */   pathPattern: () => (/* binding */ pathPattern),
/* harmony export */   peerMultiaddr: () => (/* binding */ isPeerMultiaddr),
/* harmony export */   subdomain: () => (/* binding */ subdomain),
/* harmony export */   subdomainGatewayPattern: () => (/* binding */ subdomainGatewayPattern),
/* harmony export */   url: () => (/* binding */ url),
/* harmony export */   urlOrPath: () => (/* binding */ urlOrPath)
/* harmony export */ });
/* harmony import */ var _multiformats_mafmt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @multiformats/mafmt */ "./node_modules/@multiformats/mafmt/dist/src/index.js");
/* harmony import */ var _multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @multiformats/multiaddr */ "./node_modules/@multiformats/multiaddr/dist/src/index.js");
/* harmony import */ var iso_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! iso-url */ "./node_modules/iso-url/index.js");
/* harmony import */ var multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! multiformats/bases/base32 */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base32.js");
/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! multiformats/bases/base58 */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base58.js");
/* harmony import */ var multiformats_cid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! multiformats/cid */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/cid.js");
/* harmony import */ var multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! multiformats/hashes/digest */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js");
/* harmony import */ var uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uint8arrays/to-string */ "./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/to-string.js");
/**
 * @packageDocumentation
 *
 * A suite of util methods that provides efficient validation.
 *
 * Detection of IPFS Paths and identifiers in URLs is a two-stage process:
 *
 * 1. `pathPattern`/`pathGatewayPattern`/`subdomainGatewayPattern` regex is applied to quickly identify potential candidates
 * 2. proper CID validation is applied to remove false-positives
 *
 * @example
 *
 * ```TypeScript
 * import * as isIPFS from 'is-ipfs'
 *
 * isIPFS.multihash('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.multihash('noop') // false
 *
 * isIPFS.cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true (CIDv0)
 * isIPFS.cid('bafybeiasb5vpmaounyilfuxbd3lryvosl4yefqrfahsb2esg46q6tu6y5q') // true (CIDv1 in Base32)
 * isIPFS.cid('zdj7WWeQ43G6JJvLWQWZpyHuAMq6uYWRjkBXFad11vE2LHhQ7') // true (CIDv1 in Base58btc)
 * isIPFS.cid('noop') // false
 *
 * isIPFS.base32cid('bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va') // true
 * isIPFS.base32cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 *
 * isIPFS.url('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.url('https://ipfs.io/ipfs/QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR?filename=guardian.jpg') // true
 * isIPFS.url('https://ipfs.io/ipns/github.com') // true
 * isIPFS.url('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.url('http://en.wikipedia-on-ipfs.org.ipfs.localhost:8080') // true
 * isIPFS.url('https://github.com/ipfs/js-ipfs/blob/master/README.md') // false
 * isIPFS.url('https://google.com') // false
 *
 * isIPFS.path('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.path('/ipfs/QmbcBPAwCDxRMB1Qe7CRQmxdrTSkxKwM9y6rZw2FjGtbsb/?weird-filename=test.jpg') // true
 * isIPFS.path('/ipns/github.com') // true
 * isIPFS.path('/ipfs/js-ipfs/blob/master/README.md') // false
 *
 * isIPFS.urlOrPath('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.urlOrPath('https://ipfs.io/ipns/github.com') // true
 * isIPFS.urlOrPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.urlOrPath('/ipns/github.com') // true
 * isIPFS.urlOrPath('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.urlOrPath('https://google.com') // false
 *
 * isIPFS.ipfsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.ipfsUrl('https://ipfs.io/ipfs/invalid-hash') // false
 *
 * isIPFS.ipnsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.ipnsUrl('https://ipfs.io/ipns/github.com') // true
 *
 * isIPFS.ipfsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true
 * isIPFS.ipfsPath('/ipfs/invalid-hash') // false
 *
 * isIPFS.ipnsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.ipnsPath('/ipns/github.com') // true
 *
 * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/path/to/file') // true
 * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/') // true
 * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false
 * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/file') // false
 *
 * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.subdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true
 * isIPFS.subdomain('http://www.bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // false
 * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false
 *
 * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true
 * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false
 *
 * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true
 * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.dweb.link') // false
 * isIPFS.ipnsSubdomain('http://QmcNioXSC1bfJj1dcFErhUfyjFzoX2HodkRccsFFVJJvg8.ipns.dweb.link') // false
 * isIPFS.ipnsSubdomain('http://en.wikipedia-on-ipfs.org.ipns.localhost:8080') // true (assuming DNSLink)
 * isIPFS.ipnsSubdomain('http://en-wikipedia--on--ipfs-org.ipns.localhost:8080') // true (assuming inlined DNSLink)
 * isIPFS.ipnsSubdomain('http://hostname-without-tld-.ipns.dweb.link') // false (not a CID, invalid DNS label)
 *
 * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234') // true
 * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234/http') // true
 * isIPFS.multiaddr('/ip6/::1/udp/1234') // true
 * isIPFS.multiaddr('ip6/::1/udp/1234') // false
 * isIPFS.multiaddr('/yoloinvalid/::1/udp/1234') // false
 *
 * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true
 * isIPFS.peerMultiaddr('/ipfs/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true (legacy notation)
 * isIPFS.peerMultiaddr('/ip4/127.0.0.1/tcp/1234/ws/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true
 * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4/p2p-circuit/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true
 * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io') // false (key missing, needs additional DNS lookup to tell if this is valid)
 * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN') // true (key present, ip and port can be resolved later)
 * isIPFS.peerMultiaddr('/ip4/127.0.0.1/udp/1234') // false (key missing)
 * ```
 */








const pathGatewayPattern = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/;
const pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
const defaultProtocolMatch = 1;
const defaultHashMath = 2;
// CID, libp2p-key or DNSLink
const subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
const subdomainIdMatch = 1;
const subdomainProtocolMatch = 2;
// Fully qualified domain name (FQDN) that has an explicit .tld suffix
const fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
function isMultihash(hash) {
    const formatted = convertToString(hash);
    if (formatted === false) {
        return false;
    }
    try {
        multiformats_hashes_digest__WEBPACK_IMPORTED_MODULE_6__.decode(multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_4__.base58btc.decode(`z${formatted}`));
    }
    catch {
        return false;
    }
    return true;
}
function isMultiaddr(input) {
    try {
        return Boolean((0,_multiformats_multiaddr__WEBPACK_IMPORTED_MODULE_1__.multiaddr)(input));
    }
    catch {
        return false;
    }
}
function isBase32EncodedMultibase(hash) {
    try {
        let cid;
        if (isString(hash)) {
            cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.parse(hash);
        }
        else {
            cid = multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.asCID(hash);
        }
        if (cid == null) {
            return false;
        }
        multiformats_bases_base32__WEBPACK_IMPORTED_MODULE_3__.base32.decode(cid.toString());
    }
    catch {
        return false;
    }
    return true;
}
function isCID(hash) {
    try {
        if (isString(hash)) {
            return Boolean(multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.parse(hash));
        }
        if (hash instanceof Uint8Array) {
            return Boolean(multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.decode(hash));
        }
        return Boolean(multiformats_cid__WEBPACK_IMPORTED_MODULE_5__.CID.asCID(hash)); // eslint-disable-line no-new
    }
    catch {
        return false;
    }
}
/**
 * @param {string | Uint8Array | Multiaddr} input
 */
function isPeerMultiaddr(input) {
    return isMultiaddr(input) && _multiformats_mafmt__WEBPACK_IMPORTED_MODULE_0__.P2P.matches(input);
}
/**
 * @param {string | Uint8Array} input
 * @param {RegExp | string} pattern
 * @param {number} [protocolMatch=1]
 * @param {number} [hashMatch=2]
 */
function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
    const formatted = convertToString(input);
    if (formatted === false) {
        return false;
    }
    const match = formatted.match(pattern);
    if (match == null) {
        return false;
    }
    if (match[protocolMatch] !== 'ipfs') {
        return false;
    }
    let hash = match[hashMatch];
    if (hash != null && pattern === subdomainGatewayPattern) {
        // when doing checks for subdomain context
        // ensure hash is case-insensitive
        // (browsers force-lowercase authority component anyway)
        hash = hash.toLowerCase();
    }
    return isCID(hash);
}
/**
 *
 * @param {string | Uint8Array} input
 * @param {string | RegExp} pattern
 * @param {number} [protocolMatch=1]
 * @param {number} [hashMatch=1]
 */
function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
    const formatted = convertToString(input);
    if (formatted === false) {
        return false;
    }
    const match = formatted.match(pattern);
    if (match == null) {
        return false;
    }
    if (match[protocolMatch] !== 'ipns') {
        return false;
    }
    let ipnsId = match[hashMatch];
    if (ipnsId != null && pattern === subdomainGatewayPattern) {
        // when doing checks for subdomain context
        // ensure ipnsId is case-insensitive
        // (browsers force-lowercase authority compotent anyway)
        ipnsId = ipnsId.toLowerCase();
        // Check if it is cidv1
        if (isCID(ipnsId))
            return true;
        // Check if it looks like FQDN
        try {
            if (!ipnsId.includes('.') && ipnsId.includes('-')) {
                // name without tld, assuming its inlined into a single DNS label
                // (https://github.com/ipfs/in-web-browsers/issues/169)
                // en-wikipedia--on--ipfs-org  en.wikipedia-on-ipfs.org
                ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');
            }
            // URL implementation in web browsers forces lowercase of the hostname
            const { hostname } = new iso_url__WEBPACK_IMPORTED_MODULE_2__.URL(`http://${ipnsId}`); // eslint-disable-line no-new
            // Check if potential FQDN has an explicit TLD
            return fqdnWithTld.test(hostname);
        }
        catch (e) {
            return false;
        }
    }
    return true;
}
/**
 * @param {any} input
 */
function isString(input) {
    return typeof input === 'string';
}
/**
 * @param {Uint8Array | string} input
 */
function convertToString(input) {
    if (input instanceof Uint8Array) {
        return (0,uint8arrays_to_string__WEBPACK_IMPORTED_MODULE_7__.toString)(input, 'base58btc');
    }
    if (isString(input)) {
        return input;
    }
    return false;
}
/**
 * Returns `true` if the provided `url` string includes a valid IPFS subdomain
 * (case-insensitive CIDv1) or `false` otherwise.
 */
const ipfsSubdomain = (url) => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
/**
 * Returns `true` if the provided `url` string looks like a valid IPNS subdomain
 * (CIDv1 with `libp2p-key` multicodec or something that looks like a FQDN, for
 * example `en.wikipedia-on-ipfs.org.ipns.localhost:8080`) or `false` otherwise.
 *
 * **Note:** `ipnsSubdomain` method works in offline mode: it does not perform
 * actual IPNS record lookup over DHT or other content routing method. It may
 * return false-positives:
 *
 * - To ensure IPNS record  exists, make a call to `/api/v0/name/resolve?arg=<ipnsid>`
 * - To ensure DNSLink exists, make a call to `/api/v0/dns?arg=<fqdn>`
 */
const ipnsSubdomain = (url) => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
/**
 * Returns `true` if the provided `url` string includes a valid IPFS, looks like
 * an IPNS/DNSLink subdomain or `false` otherwise.
 */
const subdomain = (url) => ipfsSubdomain(url) || ipnsSubdomain(url);
/**
 * Returns `true` if the provided string is a valid IPFS url or `false`
 * otherwise.
 */
const ipfsUrl = (url) => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);
/**
 * Returns `true` if the provided string is a valid IPNS url or `false`
 * otherwise.
 */
const ipnsUrl = (url) => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);
/**
 * Returns `true` if the provided string is a valid IPFS or IPNS url or `false`
 * otherwise.
 */
const url = (url) => ipfsUrl(url) || ipnsUrl(url) || subdomain(url);
const path = (path) => isIpfs(path, pathPattern) || isIpns(path, pathPattern);
/**
 * Returns `true` if the provided string or `Uint8Array`  is a valid `multihash`
 * or `false` otherwise.
 */

/**
 * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)
 * or `Uint8Array` represents a valid multiaddr or `false` otherwise.
 */

/**
 * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)
 * or `Uint8Array` represents a valid libp2p peer multiaddr (matching [`P2P`
 * format from `mafmt`](https://github.com/multiformats/js-mafmt#api)) or
 * `false` otherwise.
 */

/**
 * Returns `true` if the provided string, `Uint8Array` or [`CID`](https://github.com/multiformats/js-multiformats/#readme)
 * object represents a valid [CID](https://docs.ipfs.io/guides/concepts/cid/) or
 * `false` otherwise.
 */

/**
 * Returns `true` if the provided string is a valid `CID` in Base32 encoding or
 * `false` otherwise.
 */
const base32cid = (cid) => (isCID(cid) && isBase32EncodedMultibase(cid));
/**
 * Returns `true` if the provided string is a valid IPFS or IPNS path or `false`
 * otherwise.
 */
const ipfsPath = (path) => isIpfs(path, pathPattern);
/**
 * Returns `true` if the provided string is a valid IPNS path or `false`
 * otherwise.
 */
const ipnsPath = (path) => isIpns(path, pathPattern);
/**
 * Returns `true` if the provided string is a valid IPFS or IPNS url or path or
 * `false` otherwise.
 */
const urlOrPath = (x) => url(x) || path(x);
/**
 * Returns `true` if the provided string is a valid "CID path" (IPFS path
 * without `/ipfs/` prefix) or `false` otherwise.
 */
const cidPath = (path) => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Codec: () => (/* binding */ Codec),
/* harmony export */   baseX: () => (/* binding */ baseX),
/* harmony export */   from: () => (/* binding */ from),
/* harmony export */   or: () => (/* binding */ or),
/* harmony export */   rfc4648: () => (/* binding */ rfc4648)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vendor/base-x.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/base-x.js");


/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 */
class Encoder {
    name;
    prefix;
    baseEncode;
    constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        }
        else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 */
class Decoder {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        /* c8 ignore next 3 */
        if (prefix.codePointAt(0) === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        }
        else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    decoders;
    constructor(decoders) {
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) {
            return decoder.decode(input);
        }
        else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
function or(left, right) {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return new ComposedDecoder({
        ...(left.decoders ?? { [left.prefix]: left }),
        ...(right.decoders ?? { [right.prefix]: right })
    });
}
class Codec {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
function from({ name, prefix, encode, decode }) {
    return new Codec(name, prefix, encode, decode);
}
function baseX({ name, prefix, alphabet }) {
    const { encode, decode } = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__["default"])(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(decode(text))
    });
}
function decode(string, alphabet, bitsPerChar, name) {
    // Build the character lookup table:
    const codes = {};
    for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
    }
    // Count the padding bytes:
    let end = string.length;
    while (string[end - 1] === '=') {
        --end;
    }
    // Allocate the output:
    const out = new Uint8Array((end * bitsPerChar / 8) | 0);
    // Parse the data:
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    let written = 0; // Next byte to write
    for (let i = 0; i < end; ++i) {
        // Read one character from the string:
        const value = codes[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        // Append the bits to the buffer:
        buffer = (buffer << bitsPerChar) | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & (buffer >> bits);
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
}
function encode(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    for (let i = 0; i < data.length; ++i) {
        // Slurp data into the buffer:
        buffer = (buffer << 8) | data[i];
        bits += 8;
        // Write out as much as we can:
        while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet[mask & (buffer >> bits)];
        }
    }
    // Partial character:
    if (bits !== 0) {
        out += alphabet[mask & (buffer << (bitsPerChar - bits))];
    }
    // Add padding characters until we hit a byte boundary:
    if (pad) {
        while (((out.length * bitsPerChar) & 7) !== 0) {
            out += '=';
        }
    }
    return out;
}
/**
 * RFC4648 Factory
 */
function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    return from({
        prefix,
        name,
        encode(input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode(input) {
            return decode(input, alphabet, bitsPerChar, name);
        }
    });
}
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base10.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base10.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base10: () => (/* binding */ base10)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base10 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789'
});
//# sourceMappingURL=base10.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base16.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base16.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base16: () => (/* binding */ base16),
/* harmony export */   base16upper: () => (/* binding */ base16upper)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base16 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4
});
const base16upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4
});
//# sourceMappingURL=base16.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base2.js":
/*!********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base2.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base2: () => (/* binding */ base2)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base2 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1
});
//# sourceMappingURL=base2.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base256emoji.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base256emoji.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base256emoji: () => (/* binding */ base256emoji)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const alphabet = Array.from('');
const alphabetBytesToChars = (alphabet.reduce((p, c, i) => { p[i] = c; return p; }, ([])));
const alphabetCharsToBytes = (alphabet.reduce((p, c, i) => { p[c.codePointAt(0)] = i; return p; }, ([])));
function encode(data) {
    return data.reduce((p, c) => {
        p += alphabetBytesToChars[c];
        return p;
    }, '');
}
function decode(str) {
    const byts = [];
    for (const char of str) {
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === undefined) {
            throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({
    prefix: '',
    name: 'base256emoji',
    encode,
    decode
});
//# sourceMappingURL=base256emoji.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base32.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base32.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base32: () => (/* binding */ base32),
/* harmony export */   base32hex: () => (/* binding */ base32hex),
/* harmony export */   base32hexpad: () => (/* binding */ base32hexpad),
/* harmony export */   base32hexpadupper: () => (/* binding */ base32hexpadupper),
/* harmony export */   base32hexupper: () => (/* binding */ base32hexupper),
/* harmony export */   base32pad: () => (/* binding */ base32pad),
/* harmony export */   base32padupper: () => (/* binding */ base32padupper),
/* harmony export */   base32upper: () => (/* binding */ base32upper),
/* harmony export */   base32z: () => (/* binding */ base32z)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
});
const base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
});
const base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
});
const base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
});
const base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
});
const base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
});
const base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
});
const base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
});
const base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
});
//# sourceMappingURL=base32.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base36.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base36.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base36: () => (/* binding */ base36),
/* harmony export */   base36upper: () => (/* binding */ base36upper)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base36 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
});
//# sourceMappingURL=base36.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base58.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base58.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base58btc: () => (/* binding */ base58btc),
/* harmony export */   base58flickr: () => (/* binding */ base58flickr)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
});
//# sourceMappingURL=base58.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base64.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base64.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64: () => (/* binding */ base64),
/* harmony export */   base64pad: () => (/* binding */ base64pad),
/* harmony export */   base64url: () => (/* binding */ base64url),
/* harmony export */   base64urlpad: () => (/* binding */ base64urlpad)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
});
const base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
});
const base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
});
const base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
});
//# sourceMappingURL=base64.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base8.js":
/*!********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base8.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base8: () => (/* binding */ base8)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");

const base8 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3
});
//# sourceMappingURL=base8.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/identity.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/identity.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js");


const identity = (0,_base_js__WEBPACK_IMPORTED_MODULE_1__.from)({
    prefix: '\x00',
    name: 'identity',
    encode: (buf) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.toString)(buf),
    decode: (str) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromString)(str)
});
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/interface.js":
/*!************************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/interface.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// Base encoders / decoders just base encode / decode between binary and
// textual representation. They are unaware of multibase.

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/basics.js":
/*!***************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/basics.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CID: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.CID),
/* harmony export */   bases: () => (/* binding */ bases),
/* harmony export */   bytes: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.bytes),
/* harmony export */   codecs: () => (/* binding */ codecs),
/* harmony export */   digest: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.digest),
/* harmony export */   hasher: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.hasher),
/* harmony export */   hashes: () => (/* binding */ hashes),
/* harmony export */   varint: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.varint)
/* harmony export */ });
/* harmony import */ var _bases_base10_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/base10.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base10.js");
/* harmony import */ var _bases_base16_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base16.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base16.js");
/* harmony import */ var _bases_base2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base2.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base2.js");
/* harmony import */ var _bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base256emoji.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base256emoji.js");
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base32.js");
/* harmony import */ var _bases_base36_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bases/base36.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base36.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base58.js");
/* harmony import */ var _bases_base64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bases/base64.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base64.js");
/* harmony import */ var _bases_base8_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bases/base8.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base8.js");
/* harmony import */ var _bases_identity_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bases/identity.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/identity.js");
/* harmony import */ var _codecs_json_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./codecs/json.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/json.js");
/* harmony import */ var _codecs_raw_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./codecs/raw.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/raw.js");
/* harmony import */ var _hashes_identity_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./hashes/identity.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/identity.js");
/* harmony import */ var _hashes_sha2_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./hashes/sha2.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/sha2-browser.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./index.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/index.js");















const bases = { ..._bases_identity_js__WEBPACK_IMPORTED_MODULE_9__, ..._bases_base2_js__WEBPACK_IMPORTED_MODULE_2__, ..._bases_base8_js__WEBPACK_IMPORTED_MODULE_8__, ..._bases_base10_js__WEBPACK_IMPORTED_MODULE_0__, ..._bases_base16_js__WEBPACK_IMPORTED_MODULE_1__, ..._bases_base32_js__WEBPACK_IMPORTED_MODULE_4__, ..._bases_base36_js__WEBPACK_IMPORTED_MODULE_5__, ..._bases_base58_js__WEBPACK_IMPORTED_MODULE_6__, ..._bases_base64_js__WEBPACK_IMPORTED_MODULE_7__, ..._bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_3__ };
const hashes = { ..._hashes_sha2_js__WEBPACK_IMPORTED_MODULE_13__, ..._hashes_identity_js__WEBPACK_IMPORTED_MODULE_12__ };
const codecs = { raw: _codecs_raw_js__WEBPACK_IMPORTED_MODULE_11__, json: _codecs_json_js__WEBPACK_IMPORTED_MODULE_10__ };

//# sourceMappingURL=basics.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/block/interface.js":
/*!************************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/block/interface.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js":
/*!**************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coerce: () => (/* binding */ coerce),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   fromHex: () => (/* binding */ fromHex),
/* harmony export */   fromString: () => (/* binding */ fromString),
/* harmony export */   isBinary: () => (/* binding */ isBinary),
/* harmony export */   toHex: () => (/* binding */ toHex),
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
const empty = new Uint8Array(0);
function toHex(d) {
    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');
}
function fromHex(hex) {
    const hexes = hex.match(/../g);
    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;
}
function equals(aa, bb) {
    if (aa === bb)
        return true;
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
}
function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')
        return o;
    if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error('Unknown type, must be binary type');
}
function isBinary(o) {
    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString(str) {
    return new TextEncoder().encode(str);
}
function toString(b) {
    return new TextDecoder().decode(b);
}
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/cid.js":
/*!************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/cid.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CID: () => (/* binding */ CID),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   fromJSON: () => (/* binding */ fromJSON),
/* harmony export */   toJSON: () => (/* binding */ toJSON)
/* harmony export */ });
/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/base32.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base32.js");
/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base58.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base58.js");
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./varint.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/varint.js");
/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./link/interface.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/link/interface.js");





// This way TS will also expose all the types from module

function format(link, base) {
    const { bytes, version } = link;
    switch (version) {
        case 0:
            return toStringV0(bytes, baseCache(link), base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.encoder);
        default:
            return toStringV1(bytes, baseCache(link), (base ?? _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.encoder));
    }
}
function toJSON(link) {
    return {
        '/': format(link)
    };
}
function fromJSON(json) {
    return CID.parse(json['/']);
}
const cache = new WeakMap();
function baseCache(cid) {
    const baseCache = cache.get(cid);
    if (baseCache == null) {
        const baseCache = new Map();
        cache.set(cid, baseCache);
        return baseCache;
    }
    return baseCache;
}
class CID {
    code;
    version;
    multihash;
    bytes;
    '/';
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version, code, multihash, bytes) {
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        // flag to serializers that this is a CID and
        // should be treated specially
        this['/'] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
        return this;
    }
    // ArrayBufferView
    get byteOffset() {
        return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
        return this.bytes.byteLength;
    }
    toV0() {
        switch (this.version) {
            case 0: {
                return this;
            }
            case 1: {
                const { code, multihash } = this;
                if (code !== DAG_PB_CODE) {
                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');
                }
                // sha2-256
                if (multihash.code !== SHA_256_CODE) {
                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
                }
                return (CID.createV0(multihash));
            }
            default: {
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
        }
    }
    toV1() {
        switch (this.version) {
            case 0: {
                const { code, digest } = this.multihash;
                const multihash = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.create(code, digest);
                return (CID.createV1(this.code, multihash));
            }
            case 1: {
                return this;
            }
            default: {
                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
            }
        }
    }
    equals(other) {
        return CID.equals(this, other);
    }
    static equals(self, other) {
        const unknown = other;
        return (unknown != null &&
            self.code === unknown.code &&
            self.version === unknown.version &&
            _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.equals(self.multihash, unknown.multihash));
    }
    toString(base) {
        return format(this, base);
    }
    toJSON() {
        return { '/': format(this) };
    }
    link() {
        return this;
    }
    [Symbol.toStringTag] = 'CID';
    // Legacy
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
        if (input == null) {
            return null;
        }
        const value = input;
        if (value instanceof CID) {
            // If value is instance of CID then we're all set.
            return value;
        }
        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {
            // If value isn't instance of this CID class but `this.asCID === this` or
            // `value['/'] === value.bytes` is true it is CID instance coming from a
            // different implementation (diff version or duplicate). In that case we
            // rebase it to this `CID` implementation so caller is guaranteed to get
            // instance with expected API.
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));
        }
        else if (value[cidSymbol] === true) {
            // If value is a CID from older implementation that used to be tagged via
            // symbol we still rebase it to the this `CID` implementation by
            // delegating that to a constructor.
            const { version, multihash, code } = value;
            const digest = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.decode(multihash);
            return CID.create(version, code, digest);
        }
        else {
            // Otherwise value is not a CID (or an incompatible version of it) in
            // which case we return `null`.
            return null;
        }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version, code, digest) {
        if (typeof code !== 'number') {
            throw new Error('String codecs are no longer supported');
        }
        if (!(digest.bytes instanceof Uint8Array)) {
            throw new Error('Invalid digest');
        }
        switch (version) {
            case 0: {
                if (code !== DAG_PB_CODE) {
                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                }
                else {
                    return new CID(version, code, digest, digest.bytes);
                }
            }
            case 1: {
                const bytes = encodeCID(version, code, digest.bytes);
                return new CID(version, code, digest, bytes);
            }
            default: {
                throw new Error('Invalid version');
            }
        }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length !== 0) {
            throw new Error('Incorrect length');
        }
        return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error('Incorrect length');
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new _hashes_digest_js__WEBPACK_IMPORTED_MODULE_3__.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0
            ? CID.createV0(digest)
            : CID.createV1(specs.codec, digest);
        return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
            const [i, length] = _varint_js__WEBPACK_IMPORTED_MODULE_4__.decode(initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            // CIDv0
            version = 0;
            offset = 0;
        }
        else {
            codec = next();
        }
        if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = next(); // multihash code
        const digestSize = next(); // multihash length
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return { version, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        if (cid.version === 0 && source[0] !== 'Q') {
            throw Error('Version 0 CID string must not include multibase prefix');
        }
        // Cache string representation to avoid computing it on `this.toString()`
        baseCache(cid).set(prefix, source);
        return cid;
    }
}
function parseCIDtoBytes(source, base) {
    switch (source[0]) {
        // CIDv0 is parsed differently
        case 'Q': {
            const decoder = base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc;
            return [
                _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix,
                decoder.decode(`${_bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix}${source}`)
            ];
        }
        case _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix: {
            const decoder = base ?? _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc;
            return [_bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix, decoder.decode(source)];
        }
        case _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.prefix: {
            const decoder = base ?? _bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32;
            return [_bases_base32_js__WEBPACK_IMPORTED_MODULE_0__.base32.prefix, decoder.decode(source)];
        }
        default: {
            if (base == null) {
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
            }
            return [source[0], base.decode(source)];
        }
    }
}
function toStringV0(bytes, cache, base) {
    const { prefix } = base;
    if (prefix !== _bases_base58_js__WEBPACK_IMPORTED_MODULE_1__.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    }
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    }
    else {
        return cid;
    }
}
function toStringV1(bytes, cache, base) {
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    }
    else {
        return cid;
    }
}
const DAG_PB_CODE = 0x70;
const SHA_256_CODE = 0x12;
function encodeCID(version, code, multihash) {
    const codeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodingLength(version);
    const hashOffset = codeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodeTo(version, bytes, 0);
    _varint_js__WEBPACK_IMPORTED_MODULE_4__.encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
}
const cidSymbol = Symbol.for('@ipld/js-cid/CID');
//# sourceMappingURL=cid.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/interface.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/interface.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/json.js":
/*!********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/json.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   name: () => (/* binding */ name)
/* harmony export */ });
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 0x0200;
function encode(node) {
    return textEncoder.encode(JSON.stringify(node));
}
function decode(data) {
    return JSON.parse(textDecoder.decode(data));
}
//# sourceMappingURL=json.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/raw.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/raw.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   name: () => (/* binding */ name)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js");

const name = 'raw';
const code = 0x55;
function encode(node) {
    return (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(node);
}
function decode(data) {
    return (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(data);
}
//# sourceMappingURL=raw.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Digest: () => (/* binding */ Digest),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   equals: () => (/* binding */ equals)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/varint.js");


/**
 * Creates a multihash digest.
 */
function create(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code);
    const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0);
    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
}
/**
 * Turns bytes representation of multihash digest into an instance.
 */
function decode(multihash) {
    const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash);
    const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes);
    const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
        throw new Error('Incorrect length');
    }
    return new Digest(code, size, digest, bytes);
}
function equals(a, b) {
    if (a === b) {
        return true;
    }
    else {
        const data = b;
        return (a.code === data.code &&
            a.size === data.size &&
            data.bytes instanceof Uint8Array &&
            (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, data.bytes));
    }
}
/**
 * Represents a multihash digest which carries information about the
 * hashing algorithm and an actual hash digest.
 */
class Digest {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code, size, digest, bytes) {
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}
//# sourceMappingURL=digest.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/hasher.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/hasher.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hasher: () => (/* binding */ Hasher),
/* harmony export */   from: () => (/* binding */ from)
/* harmony export */ });
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js");

function from({ name, code, encode }) {
    return new Hasher(name, code, encode);
}
/**
 * Hasher represents a hashing algorithm implementation that produces as
 * `MultihashDigest`.
 */
class Hasher {
    name;
    code;
    encode;
    constructor(name, code, encode) {
        this.name = name;
        this.code = code;
        this.encode = encode;
    }
    digest(input) {
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array
                ? _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, result)
                /* c8 ignore next 1 */
                : result.then(digest => _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, digest));
        }
        else {
            throw Error('Unknown type, must be binary type');
            /* c8 ignore next 1 */
        }
    }
}
//# sourceMappingURL=hasher.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/identity.js":
/*!************************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/identity.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./digest.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js");


const code = 0x0;
const name = 'identity';
const encode = _bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce;
function digest(input) {
    return _digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, encode(input));
}
const identity = { code, name, encode, digest };
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/interface.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/interface.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// # Multihash

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/sha2-browser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/sha2-browser.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sha256: () => (/* binding */ sha256),
/* harmony export */   sha512: () => (/* binding */ sha512)
/* harmony export */ });
/* harmony import */ var _hasher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasher.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/hasher.js");
/* global crypto */

function sha(name) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name, data));
}
const sha256 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_0__.from)({
    name: 'sha2-256',
    code: 0x12,
    encode: sha('SHA-256')
});
const sha512 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_0__.from)({
    name: 'sha2-512',
    code: 0x13,
    encode: sha('SHA-512')
});
//# sourceMappingURL=sha2-browser.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CID: () => (/* reexport safe */ _cid_js__WEBPACK_IMPORTED_MODULE_1__.CID),
/* harmony export */   bytes: () => (/* reexport module object */ _bytes_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   digest: () => (/* reexport module object */ _hashes_digest_js__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   hasher: () => (/* reexport module object */ _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   varint: () => (/* reexport module object */ _varint_js__WEBPACK_IMPORTED_MODULE_4__)
/* harmony export */ });
/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js");
/* harmony import */ var _cid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cid.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/cid.js");
/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hashes/digest.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js");
/* harmony import */ var _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/hasher.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/hasher.js");
/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./varint.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/varint.js");
/* harmony import */ var _interface_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interface.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/interface.js");
/**
 * @packageDocumentation
 *
 * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.
 *
 * This library provides implementations for most basics and many others can be found in linked repositories.
 *
 * ```TypeScript
 * import { CID } from 'multiformats/cid'
 * import * as json from 'multiformats/codecs/json'
 * import { sha256 } from 'multiformats/hashes/sha2'
 *
 * const bytes = json.encode({ hello: 'world' })
 *
 * const hash = await sha256.digest(bytes)
 * const cid = CID.create(1, json.code, hash)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Creating Blocks
 *
 * ```TypeScript
 * import * as Block from 'multiformats/block'
 * import * as codec from '@ipld/dag-cbor'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * const value = { hello: 'world' }
 *
 * // encode a block
 * let block = await Block.encode({ value, codec, hasher })
 *
 * block.value // { hello: 'world' }
 * block.bytes // Uint8Array
 * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec
 *
 * // you can also decode blocks from their binary state
 * block = await Block.decode({ bytes: block.bytes, codec, hasher })
 *
 * // if you have the cid you can also verify the hash on decode
 * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })
 * ```
 *
 * ## Multibase Encoders / Decoders / Codecs
 *
 * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:
 *
 * ```TypeScript
 * import { base64 } from "multiformats/bases/base64"
 * cid.toString(base64.encoder)
 * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'
 * ```
 *
 * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:
 *
 * ```TypeScript
 * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * Dual of multibase encoder & decoder is defined as multibase codec and it exposes
 * them as `encoder` and `decoder` properties. For added convenience codecs also
 * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be
 * used as either or both:
 *
 * ```TypeScript
 * cid.toString(base64)
 * CID.parse(cid.toString(base64), base64)
 * ```
 *
 * **Note:** CID implementation comes bundled with `base32` and `base58btc`
 * multibase codecs so that CIDs can be base serialized to (version specific)
 * default base encoding and parsed without having to supply base encoders/decoders:
 *
 * ```TypeScript
 * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')
 * v1.toString()
 * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'
 *
 * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')
 * v0.toString()
 * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'
 * v0.toV1().toString()
 * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'
 * ```
 *
 * ## Multicodec Encoders / Decoders / Codecs
 *
 * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).
 * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.
 * Here is an example implementation of JSON `BlockCodec`.
 *
 * ```TypeScript
 * export const { name, code, encode, decode } = {
 *   name: 'json',
 *   code: 0x0200,
 *   encode: json => new TextEncoder().encode(JSON.stringify(json)),
 *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))
 * }
 * ```
 *
 * ## Multihash Hashers
 *
 * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:
 *
 * ```TypeScript
 * import * as hasher from 'multiformats/hashes/hasher'
 *
 * const sha256 = hasher.from({
 *   // As per multiformats table
 *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9
 *   name: 'sha2-256',
 *   code: 0x12,
 *
 *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())
 * })
 *
 * const hash = await sha256.digest(json.encode({ hello: 'world' }))
 * CID.create(1, json.code, hash)
 *
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Traversal
 *
 * This library contains higher-order functions for traversing graphs of data easily.
 *
 * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.
 *
 * ```TypeScript
 * import { walk } from 'multiformats/traversal'
 * import * as Block from 'multiformats/block'
 * import * as codec from 'multiformats/codecs/json'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * // build a DAG (a single block for this simple example)
 * const value = { hello: 'world' }
 * const block = await Block.encode({ value, codec, hasher })
 * const { cid } = block
 * console.log(cid)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 *
 * // create a loader function that also collects CIDs of blocks in
 * // their traversal order
 * const load = (cid, blocks) => async (cid) => {
 *   // fetch a block using its cid
 *   // e.g.: const block = await fetchBlockByCID(cid)
 *   blocks.push(cid)
 *   return block
 * }
 *
 * // collect blocks in this DAG starting from the root `cid`
 * const blocks = []
 * await walk({ cid, load: load(cid, blocks) })
 *
 * console.log(blocks)
 * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]
 * ```
 *
 * ## Legacy interface
 *
 * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an
 * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.
 *
 * ## Implementations
 *
 * By default, no base encodings (other than base32 & base58btc), hash functions,
 * or codec implementations are exposed by `multiformats`, you need to
 * import the ones you need yourself.
 *
 * ### Multibase codecs
 *
 * | bases                                                         | import                      | repo                                                                                              |
 * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |
 * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 *
 * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.
 *
 * ### Multihash hashers
 *
 * | hashes                                                                                                                          | import                         | repo                                                                                                               |
 * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |
 * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |
 * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |
 * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |
 * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |
 * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |
 *
 * ### IPLD codecs (multicodec)
 *
 * | codec      | import                     | repo                                                                                                   |
 * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |
 * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |
 * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |
 * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |
 * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |
 */





// This way TS will also expose all the types from module


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/interface.js":
/*!******************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/interface.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bases_interface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/interface.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/interface.js");
/* harmony import */ var _hashes_interface_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes/interface.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/interface.js");
/* harmony import */ var _codecs_interface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./codecs/interface.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/interface.js");
/* harmony import */ var _link_interface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./link/interface.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/link/interface.js");
/* harmony import */ var _block_interface_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./block/interface.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/block/interface.js");





//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/link/interface.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/link/interface.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* eslint-disable @typescript-eslint/no-unnecessary-type-constraint */
/* eslint-disable no-use-before-define */

//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/varint.js":
/*!***************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/varint.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encodeTo: () => (/* binding */ encodeTo),
/* harmony export */   encodingLength: () => (/* binding */ encodingLength)
/* harmony export */ });
/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/varint.js */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/varint.js");

function decode(data, offset = 0) {
    const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].decode(data, offset);
    return [code, _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].decode.bytes];
}
function encodeTo(int, target, offset = 0) {
    _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].encode(int, target, offset);
    return target;
}
function encodingLength(int) {
    return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__["default"].encodingLength(int);
}
//# sourceMappingURL=varint.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/base-x.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/base-x.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable */
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
/**
 * @param {string} ALPHABET
 * @param {any} name
 */
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    /**
     * @param {any[] | Iterable<number>} source
     */
    function encode(source) {
        // @ts-ignore
        if (source instanceof Uint8Array)
            ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        }
        else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while (pbegin !== pend) {
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
                carry += (256 * b58[it1]) >>> 0;
                b58[it1] = (carry % BASE) >>> 0;
                carry = (carry / BASE) >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
            it2++;
        }
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    /**
     * @param {string | string[]} source
     */
    function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        // Skip leading spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
        var b256 = new Uint8Array(size);
        // Process the characters.
        while (source[psz]) {
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) {
                return;
            }
            var i = 0;
            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
                carry += (BASE * b256[it3]) >>> 0;
                b256[it3] = (carry % 256) >>> 0;
                carry = (carry / 256) >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        // Skip trailing spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while (it4 !== size) {
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    /**
     * @param {string | string[]} string
     */
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp__multiformats_scope_baseX);
//# sourceMappingURL=base-x.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/varint.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/varint.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable */
var encode_1 = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
/**
 * @param {number} num
 * @param {number[]} out
 * @param {number} offset
 */
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
        out[offset++] = (num & 0xFF) | MSB;
        num /= 128;
    }
    while (num & MSBALL) {
        out[offset++] = (num & 0xFF) | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    // @ts-ignore
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 0x80, REST$1 = 0x7F;
/**
 * @param {string | any[]} buf
 * @param {number} offset
 */
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            // @ts-ignore
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28
            ? (b & REST$1) << shift
            : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    } while (b >= MSB$1);
    // @ts-ignore
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function (/** @type {number} */ value) {
    return (value < N1 ? 1
        : value < N2 ? 2
            : value < N3 ? 3
                : value < N4 ? 4
                    : value < N5 ? 5
                        : value < N6 ? 6
                            : value < N7 ? 7
                                : value < N8 ? 8
                                    : value < N9 ? 9
                                        : 10);
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp_varint);
//# sourceMappingURL=varint.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/alloc.js":
/*!*************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/alloc.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alloc: () => (/* binding */ alloc),
/* harmony export */   allocUnsafe: () => (/* binding */ allocUnsafe)
/* harmony export */ });
/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */
function alloc(size = 0) {
    return new Uint8Array(size);
}
/**
 * Where possible returns a Uint8Array of the requested size that references
 * uninitialized memory. Only use if you are certain you will immediately
 * overwrite every value in the returned `Uint8Array`.
 */
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
}
//# sourceMappingURL=alloc.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/to-string.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/to-string.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ "./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/util/bases.js");

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 */
function toString(array, encoding = 'utf8') {
    const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
}
//# sourceMappingURL=to-string.js.map

/***/ }),

/***/ "./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/util/bases.js":
/*!******************************************************************************!*\
  !*** ./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/util/bases.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/basics */ "./node_modules/is-ipfs/node_modules/multiformats/dist/src/basics.js");
/* harmony import */ var _alloc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! #alloc */ "./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/alloc.js");


function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf) => {
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf) => {
    let string = 'a';
    for (let i = 0; i < buf.length; i++) {
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str) => {
    str = str.substring(1);
    const buf = (0,_alloc__WEBPACK_IMPORTED_MODULE_1__.allocUnsafe)(str.length);
    for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BASES);
//# sourceMappingURL=bases.js.map

/***/ }),

/***/ "./node_modules/uint8-varint/dist/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uint8-varint/dist/src/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   decodeUint8Array: () => (/* binding */ decodeUint8Array),
/* harmony export */   decodeUint8ArrayList: () => (/* binding */ decodeUint8ArrayList),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   encodeUint8Array: () => (/* binding */ encodeUint8Array),
/* harmony export */   encodeUint8ArrayList: () => (/* binding */ encodeUint8ArrayList),
/* harmony export */   encodingLength: () => (/* binding */ encodingLength)
/* harmony export */ });
/* harmony import */ var uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays/alloc */ "./node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js");
/* eslint-disable no-fallthrough */

const N1 = Math.pow(2, 7);
const N2 = Math.pow(2, 14);
const N3 = Math.pow(2, 21);
const N4 = Math.pow(2, 28);
const N5 = Math.pow(2, 35);
const N6 = Math.pow(2, 42);
const N7 = Math.pow(2, 49);
/** Most significant bit of a byte */
const MSB = 0x80;
/** Rest of the bits in a byte */
const REST = 0x7f;
function encodingLength(value) {
    if (value < N1) {
        return 1;
    }
    if (value < N2) {
        return 2;
    }
    if (value < N3) {
        return 3;
    }
    if (value < N4) {
        return 4;
    }
    if (value < N5) {
        return 5;
    }
    if (value < N6) {
        return 6;
    }
    if (value < N7) {
        return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
        throw new RangeError('Could not encode varint');
    }
    return 8;
}
function encodeUint8Array(value, buf, offset = 0) {
    switch (encodingLength(value)) {
        case 8: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 7: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 6: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 5: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 4: {
            buf[offset++] = (value & 0xFF) | MSB;
            value >>>= 7;
        }
        case 3: {
            buf[offset++] = (value & 0xFF) | MSB;
            value >>>= 7;
        }
        case 2: {
            buf[offset++] = (value & 0xFF) | MSB;
            value >>>= 7;
        }
        case 1: {
            buf[offset++] = (value & 0xFF);
            value >>>= 7;
            break;
        }
        default: throw new Error('unreachable');
    }
    return buf;
}
function encodeUint8ArrayList(value, buf, offset = 0) {
    switch (encodingLength(value)) {
        case 8: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 7: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 6: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 5: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 4: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value >>>= 7;
        }
        case 3: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value >>>= 7;
        }
        case 2: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value >>>= 7;
        }
        case 1: {
            buf.set(offset++, (value & 0xFF));
            value >>>= 7;
            break;
        }
        default: throw new Error('unreachable');
    }
    return buf;
}
function decodeUint8Array(buf, offset) {
    let b = buf[offset];
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 1];
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 2];
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 3];
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 4];
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 5];
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 6];
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 7];
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function decodeUint8ArrayList(buf, offset) {
    let b = buf.get(offset);
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 1);
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 2);
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 3);
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 4);
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 5);
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 6);
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 7);
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function encode(value, buf, offset = 0) {
    if (buf == null) {
        buf = (0,uint8arrays_alloc__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(encodingLength(value));
    }
    if (buf instanceof Uint8Array) {
        return encodeUint8Array(value, buf, offset);
    }
    else {
        return encodeUint8ArrayList(value, buf, offset);
    }
}
function decode(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
        return decodeUint8Array(buf, offset);
    }
    else {
        return decodeUint8ArrayList(buf, offset);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js":
/*!******************************************************************************!*\
  !*** ./node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alloc: () => (/* binding */ alloc),
/* harmony export */   allocUnsafe: () => (/* binding */ allocUnsafe)
/* harmony export */ });
/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */
function alloc(size = 0) {
    return new Uint8Array(size);
}
/**
 * Where possible returns a Uint8Array of the requested size that references
 * uninitialized memory. Only use if you are certain you will immediately
 * overwrite every value in the returned `Uint8Array`.
 */
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
}
//# sourceMappingURL=alloc.js.map

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_is-ipfs_dist_src_index_js.bundle.js.map