{"version":3,"file":"849.bundle.js","mappings":"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","sources":["webpack://@bladelabs/blade-sdk.js/./node_modules/iso-url/index.js","webpack://@bladelabs/blade-sdk.js/./node_modules/iso-url/src/relative.js","webpack://@bladelabs/blade-sdk.js/./node_modules/iso-url/src/url-browser.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@libp2p/interface/dist/src/errors.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bytes.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/base-x.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base58.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base32.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/vendor/varint.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/varint.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/digest.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/cid.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base10.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base16.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base2.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base256emoji.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base36.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base64.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/base8.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/bases/identity.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/json.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/codecs/raw.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/identity.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/hasher.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/hashes/sha2-browser.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/multiformats/dist/src/basics.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/alloc.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/util/bases.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/to-string.js","webpack://@bladelabs/blade-sdk.js/./node_modules/uint8-varint/dist/src/index.js","webpack://@bladelabs/blade-sdk.js/./node_modules/uint8-varint/node_modules/uint8arrays/dist/src/alloc.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/concat.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@chainsafe/is-ip/lib/parse.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@chainsafe/is-ip/lib/parser.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/from-string.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@chainsafe/is-ip/lib/is-ip.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@chainsafe/netmask/dist/src/ip.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/dist/src/ip.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/dist/src/protocols-table.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/dist/src/convert.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/dist/src/codec.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/dist/src/multiaddr.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/dist/src/index.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/multiaddr/node_modules/uint8arrays/dist/src/equals.js","webpack://@bladelabs/blade-sdk.js/./node_modules/@multiformats/mafmt/dist/src/index.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bytes.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/base-x.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base32.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base58.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/vendor/varint.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/varint.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/digest.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/cid.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base10.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base16.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base2.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base256emoji.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base36.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base64.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/base8.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/bases/identity.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/json.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/codecs/raw.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/identity.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/hasher.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/hashes/sha2-browser.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/multiformats/dist/src/basics.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/util/bases.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/alloc.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/dist/src/index.js","webpack://@bladelabs/blade-sdk.js/./node_modules/is-ipfs/node_modules/uint8arrays/dist/src/to-string.js"],"sourcesContent":["'use strict'\n\nconst {\n  URLWithLegacySupport,\n  format,\n  URLSearchParams,\n  defaultBase\n} = require('./src/url')\nconst relative = require('./src/relative')\n\nmodule.exports = {\n  URL: URLWithLegacySupport,\n  URLSearchParams,\n  format,\n  relative,\n  defaultBase\n}\n","'use strict'\n\nconst { URLWithLegacySupport, format } = require('./url')\n\n/**\n * @param {string | undefined} url\n * @param {any} [location]\n * @param {any} [protocolMap]\n * @param {any} [defaultProtocol]\n */\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n  let protocol = location.protocol\n    ? location.protocol.replace(':', '')\n    : 'http'\n\n  // Check protocol map\n  protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':'\n  let urlParsed\n\n  try {\n    urlParsed = new URLWithLegacySupport(url)\n  } catch (err) {\n    urlParsed = {}\n  }\n\n  const base = Object.assign({}, location, {\n    protocol: protocol || urlParsed.protocol,\n    host: location.host || urlParsed.host\n  })\n\n  return new URLWithLegacySupport(url, format(base)).toString()\n}\n","'use strict'\n\nconst isReactNative =\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative'\n\nfunction getDefaultBase () {\n  if (isReactNative) {\n    return 'http://localhost'\n  }\n  // in some environments i.e. cloudflare workers location is not available\n  if (!self.location) {\n    return ''\n  }\n\n  return self.location.protocol + '//' + self.location.host\n}\n\nconst URL = self.URL\nconst defaultBase = getDefaultBase()\n\nclass URLWithLegacySupport {\n  constructor (url = '', base = defaultBase) {\n    this.super = new URL(url, base)\n    this.path = this.pathname + this.search\n    this.auth =\n            this.username && this.password\n              ? this.username + ':' + this.password\n              : null\n\n    this.query =\n            this.search && this.search.startsWith('?')\n              ? this.search.slice(1)\n              : null\n  }\n\n  get hash () {\n    return this.super.hash\n  }\n\n  get host () {\n    return this.super.host\n  }\n\n  get hostname () {\n    return this.super.hostname\n  }\n\n  get href () {\n    return this.super.href\n  }\n\n  get origin () {\n    return this.super.origin\n  }\n\n  get password () {\n    return this.super.password\n  }\n\n  get pathname () {\n    return this.super.pathname\n  }\n\n  get port () {\n    return this.super.port\n  }\n\n  get protocol () {\n    return this.super.protocol\n  }\n\n  get search () {\n    return this.super.search\n  }\n\n  get searchParams () {\n    return this.super.searchParams\n  }\n\n  get username () {\n    return this.super.username\n  }\n\n  set hash (hash) {\n    this.super.hash = hash\n  }\n\n  set host (host) {\n    this.super.host = host\n  }\n\n  set hostname (hostname) {\n    this.super.hostname = hostname\n  }\n\n  set href (href) {\n    this.super.href = href\n  }\n\n  set password (password) {\n    this.super.password = password\n  }\n\n  set pathname (pathname) {\n    this.super.pathname = pathname\n  }\n\n  set port (port) {\n    this.super.port = port\n  }\n\n  set protocol (protocol) {\n    this.super.protocol = protocol\n  }\n\n  set search (search) {\n    this.super.search = search\n  }\n\n  set username (username) {\n    this.super.username = username\n  }\n\n  /**\n   * @param {any} o\n   */\n  static createObjectURL (o) {\n    return URL.createObjectURL(o)\n  }\n\n  /**\n   * @param {string} o\n   */\n  static revokeObjectURL (o) {\n    URL.revokeObjectURL(o)\n  }\n\n  toJSON () {\n    return this.super.toJSON()\n  }\n\n  toString () {\n    return this.super.toString()\n  }\n\n  format () {\n    return this.toString()\n  }\n}\n\n/**\n * @param {string | import('url').UrlObject} obj\n */\nfunction format (obj) {\n  if (typeof obj === 'string') {\n    const url = new URL(obj)\n\n    return url.toString()\n  }\n\n  if (!(obj instanceof URL)) {\n    const userPass =\n            // @ts-ignore its not supported in node but we normalise\n            obj.username && obj.password\n              // @ts-ignore its not supported in node but we normalise\n              ? `${obj.username}:${obj.password}@`\n              : ''\n    const auth = obj.auth ? obj.auth + '@' : ''\n    const port = obj.port ? ':' + obj.port : ''\n    const protocol = obj.protocol ? obj.protocol + '//' : ''\n    const host = obj.host || ''\n    const hostname = obj.hostname || ''\n    const search = obj.search || (obj.query ? '?' + obj.query : '')\n    const hash = obj.hash || ''\n    const pathname = obj.pathname || ''\n    // @ts-ignore - path is not supported in node but we normalise\n    const path = obj.path || pathname + search\n\n    return `${protocol}${userPass || auth}${\n            host || hostname + port\n        }${path}${hash}`\n  }\n}\n\nmodule.exports = {\n  URLWithLegacySupport,\n  URLSearchParams: self.URLSearchParams,\n  defaultBase,\n  format\n}\n","/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n    code;\n    type;\n    constructor(message = 'The operation was aborted') {\n        super(message);\n        this.name = 'AbortError';\n        this.code = AbortError.code;\n        this.type = AbortError.type;\n    }\n    static code = 'ABORT_ERR';\n    static type = 'aborted';\n}\nexport class CodeError extends Error {\n    code;\n    props;\n    constructor(message, code, props) {\n        super(message);\n        this.code = code;\n        this.name = props?.name ?? 'CodeError';\n        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions\n    }\n}\nexport class AggregateCodeError extends AggregateError {\n    code;\n    props;\n    constructor(errors, message, code, props) {\n        super(errors, message);\n        this.code = code;\n        this.name = props?.name ?? 'AggregateCodeError';\n        this.props = props ?? {}; // eslint-disable-line @typescript-eslint/consistent-type-assertions\n    }\n}\nexport class UnexpectedPeerError extends Error {\n    code;\n    constructor(message = 'Unexpected Peer') {\n        super(message);\n        this.name = 'UnexpectedPeerError';\n        this.code = UnexpectedPeerError.code;\n    }\n    static code = 'ERR_UNEXPECTED_PEER';\n}\nexport class InvalidCryptoExchangeError extends Error {\n    code;\n    constructor(message = 'Invalid crypto exchange') {\n        super(message);\n        this.name = 'InvalidCryptoExchangeError';\n        this.code = InvalidCryptoExchangeError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_EXCHANGE';\n}\nexport class InvalidCryptoTransmissionError extends Error {\n    code;\n    constructor(message = 'Invalid crypto transmission') {\n        super(message);\n        this.name = 'InvalidCryptoTransmissionError';\n        this.code = InvalidCryptoTransmissionError.code;\n    }\n    static code = 'ERR_INVALID_CRYPTO_TRANSMISSION';\n}\n// Error codes\nexport const ERR_TIMEOUT = 'ERR_TIMEOUT';\nexport const ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS';\nexport const ERR_NOT_FOUND = 'ERR_NOT_FOUND';\nexport const ERR_INVALID_MESSAGE = 'ERR_INVALID_MESSAGE';\n//# sourceMappingURL=errors.js.map","export const empty = new Uint8Array(0);\nexport function toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nexport function fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nexport function equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nexport function isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nexport function fromString(str) {\n    return new TextEncoder().encode(str);\n}\nexport function toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;\n//# sourceMappingURL=base-x.js.map","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        /* c8 ignore next 3 */\n        if (prefix.codePointAt(0) === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefix.codePointAt(0);\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { baseX } from './base.js';\nexport const base58btc = baseX({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;\n//# sourceMappingURL=varint.js.map","import varint from './vendor/varint.js';\nexport function decode(data, offset = 0) {\n    const code = varint.decode(data, offset);\n    return [code, varint.decode.bytes];\n}\nexport function encodeTo(int, target, offset = 0) {\n    varint.encode(int, target, offset);\n    return target;\n}\nexport function encodingLength(int) {\n    return varint.encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map","import { coerce, equals as equalBytes } from '../bytes.js';\nimport * as varint from '../varint.js';\n/**\n * Creates a multihash digest.\n */\nexport function create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = varint.encodingLength(code);\n    const digestOffset = sizeOffset + varint.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    varint.encodeTo(code, bytes, 0);\n    varint.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode(multihash) {\n    const bytes = coerce(multihash);\n    const [code, sizeOffset] = varint.decode(bytes);\n    const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            equalBytes(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n//# sourceMappingURL=digest.js.map","import { base32 } from './bases/base32.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nexport function format(link, base) {\n    const { bytes, version } = link;\n    switch (version) {\n        case 0:\n            return toStringV0(bytes, baseCache(link), base ?? base58btc.encoder);\n        default:\n            return toStringV1(bytes, baseCache(link), (base ?? base32.encoder));\n    }\n}\nexport function toJSON(link) {\n    return {\n        '/': format(link)\n    };\n}\nexport function fromJSON(json) {\n    return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n    const baseCache = cache.get(cid);\n    if (baseCache == null) {\n        const baseCache = new Map();\n        cache.set(cid, baseCache);\n        return baseCache;\n    }\n    return baseCache;\n}\nexport class CID {\n    code;\n    version;\n    multihash;\n    bytes;\n    '/';\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param multihash - (Multi)hash of the of the content.\n     */\n    constructor(version, code, multihash, bytes) {\n        this.code = code;\n        this.version = version;\n        this.multihash = multihash;\n        this.bytes = bytes;\n        // flag to serializers that this is a CID and\n        // should be treated specially\n        this['/'] = bytes;\n    }\n    /**\n     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n     * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n     *\n     * @deprecated\n     */\n    get asCID() {\n        return this;\n    }\n    // ArrayBufferView\n    get byteOffset() {\n        return this.bytes.byteOffset;\n    }\n    // ArrayBufferView\n    get byteLength() {\n        return this.bytes.byteLength;\n    }\n    toV0() {\n        switch (this.version) {\n            case 0: {\n                return this;\n            }\n            case 1: {\n                const { code, multihash } = this;\n                if (code !== DAG_PB_CODE) {\n                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n                }\n                // sha2-256\n                if (multihash.code !== SHA_256_CODE) {\n                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n                }\n                return (CID.createV0(multihash));\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n            }\n        }\n    }\n    toV1() {\n        switch (this.version) {\n            case 0: {\n                const { code, digest } = this.multihash;\n                const multihash = Digest.create(code, digest);\n                return (CID.createV1(this.code, multihash));\n            }\n            case 1: {\n                return this;\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n            }\n        }\n    }\n    equals(other) {\n        return CID.equals(this, other);\n    }\n    static equals(self, other) {\n        const unknown = other;\n        return (unknown != null &&\n            self.code === unknown.code &&\n            self.version === unknown.version &&\n            Digest.equals(self.multihash, unknown.multihash));\n    }\n    toString(base) {\n        return format(this, base);\n    }\n    toJSON() {\n        return { '/': format(this) };\n    }\n    link() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'CID';\n    // Legacy\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `CID(${this.toString()})`;\n    }\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     */\n    static asCID(input) {\n        if (input == null) {\n            return null;\n        }\n        const value = input;\n        if (value instanceof CID) {\n            // If value is instance of CID then we're all set.\n            return value;\n        }\n        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n            // If value isn't instance of this CID class but `this.asCID === this` or\n            // `value['/'] === value.bytes` is true it is CID instance coming from a\n            // different implementation (diff version or duplicate). In that case we\n            // rebase it to this `CID` implementation so caller is guaranteed to get\n            // instance with expected API.\n            const { version, code, multihash, bytes } = value;\n            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n        }\n        else if (value[cidSymbol] === true) {\n            // If value is a CID from older implementation that used to be tagged via\n            // symbol we still rebase it to the this `CID` implementation by\n            // delegating that to a constructor.\n            const { version, multihash, code } = value;\n            const digest = Digest.decode(multihash);\n            return CID.create(version, code, digest);\n        }\n        else {\n            // Otherwise value is not a CID (or an incompatible version of it) in\n            // which case we return `null`.\n            return null;\n        }\n    }\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param digest - (Multi)hash of the of the content.\n     */\n    static create(version, code, digest) {\n        if (typeof code !== 'number') {\n            throw new Error('String codecs are no longer supported');\n        }\n        if (!(digest.bytes instanceof Uint8Array)) {\n            throw new Error('Invalid digest');\n        }\n        switch (version) {\n            case 0: {\n                if (code !== DAG_PB_CODE) {\n                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n                }\n                else {\n                    return new CID(version, code, digest, digest.bytes);\n                }\n            }\n            case 1: {\n                const bytes = encodeCID(version, code, digest.bytes);\n                return new CID(version, code, digest, bytes);\n            }\n            default: {\n                throw new Error('Invalid version');\n            }\n        }\n    }\n    /**\n     * Simplified version of `create` for CIDv0.\n     */\n    static createV0(digest) {\n        return CID.create(0, DAG_PB_CODE, digest);\n    }\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @param code - Content encoding format code.\n     * @param digest - Multihash of the content.\n     */\n    static createV1(code, digest) {\n        return CID.create(1, code, digest);\n    }\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     */\n    static decode(bytes) {\n        const [cid, remainder] = CID.decodeFirst(bytes);\n        if (remainder.length !== 0) {\n            throw new Error('Incorrect length');\n        }\n        return cid;\n    }\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     */\n    static decodeFirst(bytes) {\n        const specs = CID.inspectBytes(bytes);\n        const prefixSize = specs.size - specs.multihashSize;\n        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n        if (multihashBytes.byteLength !== specs.multihashSize) {\n            throw new Error('Incorrect length');\n        }\n        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n        const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n        const cid = specs.version === 0\n            ? CID.createV0(digest)\n            : CID.createV1(specs.codec, digest);\n        return [cid, bytes.subarray(specs.size)];\n    }\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     */\n    static inspectBytes(initialBytes) {\n        let offset = 0;\n        const next = () => {\n            const [i, length] = varint.decode(initialBytes.subarray(offset));\n            offset += length;\n            return i;\n        };\n        let version = next();\n        let codec = DAG_PB_CODE;\n        if (version === 18) {\n            // CIDv0\n            version = 0;\n            offset = 0;\n        }\n        else {\n            codec = next();\n        }\n        if (version !== 0 && version !== 1) {\n            throw new RangeError(`Invalid CID version ${version}`);\n        }\n        const prefixSize = offset;\n        const multihashCode = next(); // multihash code\n        const digestSize = next(); // multihash length\n        const size = offset + digestSize;\n        const multihashSize = size - prefixSize;\n        return { version, codec, multihashCode, digestSize, multihashSize, size };\n    }\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     */\n    static parse(source, base) {\n        const [prefix, bytes] = parseCIDtoBytes(source, base);\n        const cid = CID.decode(bytes);\n        if (cid.version === 0 && source[0] !== 'Q') {\n            throw Error('Version 0 CID string must not include multibase prefix');\n        }\n        // Cache string representation to avoid computing it on `this.toString()`\n        baseCache(cid).set(prefix, source);\n        return cid;\n    }\n}\nfunction parseCIDtoBytes(source, base) {\n    switch (source[0]) {\n        // CIDv0 is parsed differently\n        case 'Q': {\n            const decoder = base ?? base58btc;\n            return [\n                base58btc.prefix,\n                decoder.decode(`${base58btc.prefix}${source}`)\n            ];\n        }\n        case base58btc.prefix: {\n            const decoder = base ?? base58btc;\n            return [base58btc.prefix, decoder.decode(source)];\n        }\n        case base32.prefix: {\n            const decoder = base ?? base32;\n            return [base32.prefix, decoder.decode(source)];\n        }\n        default: {\n            if (base == null) {\n                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n            }\n            return [source[0], base.decode(source)];\n        }\n    }\n}\nfunction toStringV0(bytes, cache, base) {\n    const { prefix } = base;\n    if (prefix !== base58btc.prefix) {\n        throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n    }\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes).slice(1);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nfunction toStringV1(bytes, cache, base) {\n    const { prefix } = base;\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n    const codeOffset = varint.encodingLength(version);\n    const hashOffset = codeOffset + varint.encodingLength(code);\n    const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n    varint.encodeTo(version, bytes, 0);\n    varint.encodeTo(code, bytes, codeOffset);\n    bytes.set(multihash, hashOffset);\n    return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\n//# sourceMappingURL=cid.js.map","import { baseX } from './base.js';\nexport const base10 = baseX({\n    prefix: '9',\n    name: 'base10',\n    alphabet: '0123456789'\n});\n//# sourceMappingURL=base10.js.map","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n    prefix: 'f',\n    name: 'base16',\n    alphabet: '0123456789abcdef',\n    bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n    prefix: 'F',\n    name: 'base16upper',\n    alphabet: '0123456789ABCDEF',\n    bitsPerChar: 4\n});\n//# sourceMappingURL=base16.js.map","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n    prefix: '0',\n    name: 'base2',\n    alphabet: '01',\n    bitsPerChar: 1\n});\n//# sourceMappingURL=base2.js.map","import { from } from './base.js';\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂');\nconst alphabetBytesToChars = (alphabet.reduce((p, c, i) => { p[i] = c; return p; }, ([])));\nconst alphabetCharsToBytes = (alphabet.reduce((p, c, i) => { p[c.codePointAt(0)] = i; return p; }, ([])));\nfunction encode(data) {\n    return data.reduce((p, c) => {\n        p += alphabetBytesToChars[c];\n        return p;\n    }, '');\n}\nfunction decode(str) {\n    const byts = [];\n    for (const char of str) {\n        const byt = alphabetCharsToBytes[char.codePointAt(0)];\n        if (byt === undefined) {\n            throw new Error(`Non-base256emoji character: ${char}`);\n        }\n        byts.push(byt);\n    }\n    return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n    prefix: '🚀',\n    name: 'base256emoji',\n    encode,\n    decode\n});\n//# sourceMappingURL=base256emoji.js.map","import { baseX } from './base.js';\nexport const base36 = baseX({\n    prefix: 'k',\n    name: 'base36',\n    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n    prefix: 'K',\n    name: 'base36upper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base36.js.map","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n    prefix: 'm',\n    name: 'base64',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n    prefix: 'M',\n    name: 'base64pad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n    prefix: 'u',\n    name: 'base64url',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n    bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n    prefix: 'U',\n    name: 'base64urlpad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n    bitsPerChar: 6\n});\n//# sourceMappingURL=base64.js.map","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n    prefix: '7',\n    name: 'base8',\n    alphabet: '01234567',\n    bitsPerChar: 3\n});\n//# sourceMappingURL=base8.js.map","import { fromString, toString } from '../bytes.js';\nimport { from } from './base.js';\nexport const identity = from({\n    prefix: '\\x00',\n    name: 'identity',\n    encode: (buf) => toString(buf),\n    decode: (str) => fromString(str)\n});\n//# sourceMappingURL=identity.js.map","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 0x0200;\nexport function encode(node) {\n    return textEncoder.encode(JSON.stringify(node));\n}\nexport function decode(data) {\n    return JSON.parse(textDecoder.decode(data));\n}\n//# sourceMappingURL=json.js.map","import { coerce } from '../bytes.js';\nexport const name = 'raw';\nexport const code = 0x55;\nexport function encode(node) {\n    return coerce(node);\n}\nexport function decode(data) {\n    return coerce(data);\n}\n//# sourceMappingURL=raw.js.map","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0x0;\nconst name = 'identity';\nconst encode = coerce;\nfunction digest(input) {\n    return Digest.create(code, encode(input));\n}\nexport const identity = { code, name, encode, digest };\n//# sourceMappingURL=identity.js.map","import * as Digest from './digest.js';\nexport function from({ name, code, encode }) {\n    return new Hasher(name, code, encode);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher {\n    name;\n    code;\n    encode;\n    constructor(name, code, encode) {\n        this.name = name;\n        this.code = code;\n        this.encode = encode;\n    }\n    digest(input) {\n        if (input instanceof Uint8Array) {\n            const result = this.encode(input);\n            return result instanceof Uint8Array\n                ? Digest.create(this.code, result)\n                /* c8 ignore next 1 */\n                : result.then(digest => Digest.create(this.code, digest));\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n            /* c8 ignore next 1 */\n        }\n    }\n}\n//# sourceMappingURL=hasher.js.map","/* global crypto */\nimport { from } from './hasher.js';\nfunction sha(name) {\n    return async (data) => new Uint8Array(await crypto.subtle.digest(name, data));\n}\nexport const sha256 = from({\n    name: 'sha2-256',\n    code: 0x12,\n    encode: sha('SHA-256')\n});\nexport const sha512 = from({\n    name: 'sha2-512',\n    code: 0x13,\n    encode: sha('SHA-512')\n});\n//# sourceMappingURL=sha2-browser.js.map","import * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base2 from './bases/base2.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base8 from './bases/base8.js';\nimport * as identityBase from './bases/identity.js';\nimport * as json from './codecs/json.js';\nimport * as raw from './codecs/raw.js';\nimport * as identity from './hashes/identity.js';\nimport * as sha2 from './hashes/sha2.js';\nimport { CID, hasher, digest, varint, bytes } from './index.js';\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji };\nexport const hashes = { ...sha2, ...identity };\nexport const codecs = { raw, json };\nexport { CID, hasher, digest, varint, bytes };\n//# sourceMappingURL=basics.js.map","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '#alloc';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import bases, {} from './util/bases.js';\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString(array, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // strip multibase prefix\n    return base.encoder.encode(array).substring(1);\n}\n//# sourceMappingURL=to-string.js.map","/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc';\nconst N1 = Math.pow(2, 7);\nconst N2 = Math.pow(2, 14);\nconst N3 = Math.pow(2, 21);\nconst N4 = Math.pow(2, 28);\nconst N5 = Math.pow(2, 35);\nconst N6 = Math.pow(2, 42);\nconst N7 = Math.pow(2, 49);\n/** Most significant bit of a byte */\nconst MSB = 0x80;\n/** Rest of the bits in a byte */\nconst REST = 0x7f;\nexport function encodingLength(value) {\n    if (value < N1) {\n        return 1;\n    }\n    if (value < N2) {\n        return 2;\n    }\n    if (value < N3) {\n        return 3;\n    }\n    if (value < N4) {\n        return 4;\n    }\n    if (value < N5) {\n        return 5;\n    }\n    if (value < N6) {\n        return 6;\n    }\n    if (value < N7) {\n        return 7;\n    }\n    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n        throw new RangeError('Could not encode varint');\n    }\n    return 8;\n}\nexport function encodeUint8Array(value, buf, offset = 0) {\n    switch (encodingLength(value)) {\n        case 8: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 7: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 6: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 5: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value /= 128;\n        }\n        case 4: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 3: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 2: {\n            buf[offset++] = (value & 0xFF) | MSB;\n            value >>>= 7;\n        }\n        case 1: {\n            buf[offset++] = (value & 0xFF);\n            value >>>= 7;\n            break;\n        }\n        default: throw new Error('unreachable');\n    }\n    return buf;\n}\nexport function encodeUint8ArrayList(value, buf, offset = 0) {\n    switch (encodingLength(value)) {\n        case 8: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 7: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 6: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 5: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value /= 128;\n        }\n        case 4: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 3: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 2: {\n            buf.set(offset++, (value & 0xFF) | MSB);\n            value >>>= 7;\n        }\n        case 1: {\n            buf.set(offset++, (value & 0xFF));\n            value >>>= 7;\n            break;\n        }\n        default: throw new Error('unreachable');\n    }\n    return buf;\n}\nexport function decodeUint8Array(buf, offset) {\n    let b = buf[offset];\n    let res = 0;\n    res += b & REST;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 1];\n    res += (b & REST) << 7;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 2];\n    res += (b & REST) << 14;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 3];\n    res += (b & REST) << 21;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 4];\n    res += (b & REST) * N4;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 5];\n    res += (b & REST) * N5;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 6];\n    res += (b & REST) * N6;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf[offset + 7];\n    res += (b & REST) * N7;\n    if (b < MSB) {\n        return res;\n    }\n    throw new RangeError('Could not decode varint');\n}\nexport function decodeUint8ArrayList(buf, offset) {\n    let b = buf.get(offset);\n    let res = 0;\n    res += b & REST;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 1);\n    res += (b & REST) << 7;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 2);\n    res += (b & REST) << 14;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 3);\n    res += (b & REST) << 21;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 4);\n    res += (b & REST) * N4;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 5);\n    res += (b & REST) * N5;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 6);\n    res += (b & REST) * N6;\n    if (b < MSB) {\n        return res;\n    }\n    b = buf.get(offset + 7);\n    res += (b & REST) * N7;\n    if (b < MSB) {\n        return res;\n    }\n    throw new RangeError('Could not decode varint');\n}\nexport function encode(value, buf, offset = 0) {\n    if (buf == null) {\n        buf = allocUnsafe(encodingLength(value));\n    }\n    if (buf instanceof Uint8Array) {\n        return encodeUint8Array(value, buf, offset);\n    }\n    else {\n        return encodeUint8ArrayList(value, buf, offset);\n    }\n}\nexport function decode(buf, offset = 0) {\n    if (buf instanceof Uint8Array) {\n        return decodeUint8Array(buf, offset);\n    }\n    else {\n        return decodeUint8ArrayList(buf, offset);\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc.js.map","import { allocUnsafe } from '#alloc';\nimport { asUint8Array } from '#util/as-uint8array';\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat(arrays, length) {\n    if (length == null) {\n        length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n    }\n    const output = allocUnsafe(length);\n    let offset = 0;\n    for (const arr of arrays) {\n        output.set(arr, offset);\n        offset += arr.length;\n    }\n    return asUint8Array(output);\n}\n//# sourceMappingURL=concat.js.map","import { Parser } from \"./parser.js\";\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\nconst parser = new Parser();\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input) {\n    if (input.length > MAX_IPV4_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input) {\n    // strip zone index if it is present\n    if (input.includes(\"%\")) {\n        input = input.split(\"%\")[0];\n    }\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input) {\n    // strip zone index if it is present\n    if (input.includes(\"%\")) {\n        input = input.split(\"%\")[0];\n    }\n    if (input.length > MAX_IPV6_LENGTH) {\n        return undefined;\n    }\n    return parser.new(input).parseWith(() => parser.readIPAddr());\n}\n//# sourceMappingURL=parse.js.map","/* eslint-disable @typescript-eslint/no-unsafe-return */\nexport class Parser {\n    index = 0;\n    input = \"\";\n    new(input) {\n        this.index = 0;\n        this.input = input;\n        return this;\n    }\n    /** Run a parser, and restore the pre-parse state if it fails. */\n    readAtomically(fn) {\n        const index = this.index;\n        const result = fn();\n        if (result === undefined) {\n            this.index = index;\n        }\n        return result;\n    }\n    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n    parseWith(fn) {\n        const result = fn();\n        if (this.index !== this.input.length) {\n            return undefined;\n        }\n        return result;\n    }\n    /** Peek the next character from the input */\n    peekChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index];\n    }\n    /** Read the next character from the input */\n    readChar() {\n        if (this.index >= this.input.length) {\n            return undefined;\n        }\n        return this.input[this.index++];\n    }\n    /** Read the next character from the input if it matches the target. */\n    readGivenChar(target) {\n        return this.readAtomically(() => {\n            const char = this.readChar();\n            if (char !== target) {\n                return undefined;\n            }\n            return char;\n        });\n    }\n    /**\n     * Helper for reading separators in an indexed loop. Reads the separator\n     * character iff index > 0, then runs the parser. When used in a loop,\n     * the separator character will only be read on index > 0 (see\n     * readIPv4Addr for an example)\n     */\n    readSeparator(sep, index, inner) {\n        return this.readAtomically(() => {\n            if (index > 0) {\n                if (this.readGivenChar(sep) === undefined) {\n                    return undefined;\n                }\n            }\n            return inner();\n        });\n    }\n    /**\n     * Read a number off the front of the input in the given radix, stopping\n     * at the first non-digit character or eof. Fails if the number has more\n     * digits than max_digits or if there is no number.\n     */\n    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {\n        return this.readAtomically(() => {\n            let result = 0;\n            let digitCount = 0;\n            const leadingChar = this.peekChar();\n            if (leadingChar === undefined) {\n                return undefined;\n            }\n            const hasLeadingZero = leadingChar === \"0\";\n            const maxValue = 2 ** (8 * maxBytes) - 1;\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const digit = this.readAtomically(() => {\n                    const char = this.readChar();\n                    if (char === undefined) {\n                        return undefined;\n                    }\n                    const num = Number.parseInt(char, radix);\n                    if (Number.isNaN(num)) {\n                        return undefined;\n                    }\n                    return num;\n                });\n                if (digit === undefined) {\n                    break;\n                }\n                result *= radix;\n                result += digit;\n                if (result > maxValue) {\n                    return undefined;\n                }\n                digitCount += 1;\n                if (maxDigits !== undefined) {\n                    if (digitCount > maxDigits) {\n                        return undefined;\n                    }\n                }\n            }\n            if (digitCount === 0) {\n                return undefined;\n            }\n            else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n                return undefined;\n            }\n            else {\n                return result;\n            }\n        });\n    }\n    /** Read an IPv4 address. */\n    readIPv4Addr() {\n        return this.readAtomically(() => {\n            const out = new Uint8Array(4);\n            for (let i = 0; i < out.length; i++) {\n                const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n                if (ix === undefined) {\n                    return undefined;\n                }\n                out[i] = ix;\n            }\n            return out;\n        });\n    }\n    /** Read an IPv6 Address. */\n    readIPv6Addr() {\n        /**\n         * Read a chunk of an IPv6 address into `groups`. Returns the number\n         * of groups read, along with a bool indicating if an embedded\n         * trailing IPv4 address was read. Specifically, read a series of\n         * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n         * trailing embedded IPv4 address.\n         */\n        const readGroups = (groups) => {\n            for (let i = 0; i < groups.length / 2; i++) {\n                const ix = i * 2;\n                // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n                if (i < groups.length - 3) {\n                    const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n                    if (ipv4 !== undefined) {\n                        groups[ix] = ipv4[0];\n                        groups[ix + 1] = ipv4[1];\n                        groups[ix + 2] = ipv4[2];\n                        groups[ix + 3] = ipv4[3];\n                        return [ix + 4, true];\n                    }\n                }\n                const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n                if (group === undefined) {\n                    return [ix, false];\n                }\n                groups[ix] = group >> 8;\n                groups[ix + 1] = group & 255;\n            }\n            return [groups.length, false];\n        };\n        return this.readAtomically(() => {\n            // Read the front part of the address; either the whole thing, or up to the first ::\n            const head = new Uint8Array(16);\n            const [headSize, headIp4] = readGroups(head);\n            if (headSize === 16) {\n                return head;\n            }\n            // IPv4 part is not allowed before `::`\n            if (headIp4) {\n                return undefined;\n            }\n            // Read `::` if previous code parsed less than 8 groups.\n            // `::` indicates one or more groups of 16 bits of zeros.\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            if (this.readGivenChar(\":\") === undefined) {\n                return undefined;\n            }\n            // Read the back part of the address. The :: must contain at least one\n            // set of zeroes, so our max length is 7.\n            const tail = new Uint8Array(14);\n            const limit = 16 - (headSize + 2);\n            const [tailSize] = readGroups(tail.subarray(0, limit));\n            // Concat the head and tail of the IP address\n            head.set(tail.subarray(0, tailSize), 16 - tailSize);\n            return head;\n        });\n    }\n    /** Read an IP Address, either IPv4 or IPv6. */\n    readIPAddr() {\n        return this.readIPv4Addr() ?? this.readIPv6Addr();\n    }\n}\n//# sourceMappingURL=parser.js.map","import bases, {} from './util/bases.js';\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString(string, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // add multibase prefix\n    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n//# sourceMappingURL=from-string.js.map","import { parseIP, parseIPv4, parseIPv6 } from \"./parse.js\";\n/** Check if `input` is IPv4. */\nexport function isIPv4(input) {\n    return Boolean(parseIPv4(input));\n}\n/** Check if `input` is IPv6. */\nexport function isIPv6(input) {\n    return Boolean(parseIPv6(input));\n}\n/** Check if `input` is IPv4 or IPv6. */\nexport function isIP(input) {\n    return Boolean(parseIP(input));\n}\n/**\n * @returns `6` if `input` is IPv6, `4` if `input` is IPv4, or `undefined` if `input` is neither.\n */\nexport function ipVersion(input) {\n    if (isIPv4(input)) {\n        return 4;\n    }\n    else if (isIPv6(input)) {\n        return 6;\n    }\n    else {\n        return undefined;\n    }\n}\n//# sourceMappingURL=is-ip.js.map","import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\nexport function maskIp(ip, mask) {\n    if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n        mask = mask.slice(12);\n    }\n    if (mask.length === IPv4Len &&\n        ip.length === IPv6Len &&\n        deepEqual(ip, ipv4Prefix, 0, 11)) {\n        ip = ip.slice(12);\n    }\n    const n = ip.length;\n    if (n != mask.length) {\n        throw new Error(\"Failed to mask ip\");\n    }\n    const out = new Uint8Array(n);\n    for (let i = 0; i < n; i++) {\n        out[i] = ip[i] & mask[i];\n    }\n    return out;\n}\nexport function containsIp(net, ip) {\n    if (typeof ip === \"string\") {\n        ip = parseIP(ip);\n    }\n    if (ip == null)\n        throw new Error(\"Invalid ip\");\n    if (ip.length !== net.network.length) {\n        return false;\n    }\n    for (let i = 0; i < ip.length; i++) {\n        if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function iPv4FromIPv6(ip) {\n    if (!isIPv4mappedIPv6(ip)) {\n        throw new Error(\"Must have 0xffff prefix\");\n    }\n    return ip.slice(12);\n}\nexport function isIPv4mappedIPv6(ip) {\n    return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n//# sourceMappingURL=ip.js.map","import { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport { isIP } from '@chainsafe/is-ip';\nexport const isV4 = isIPv4;\nexport const isV6 = isIPv6;\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const toBytes = function (ip) {\n    let offset = 0;\n    ip = ip.toString().trim();\n    if (isV4(ip)) {\n        const bytes = new Uint8Array(offset + 4);\n        ip.split(/\\./g).forEach((byte) => {\n            bytes[offset++] = parseInt(byte, 10) & 0xff;\n        });\n        return bytes;\n    }\n    if (isV6(ip)) {\n        const sections = ip.split(':', 8);\n        let i;\n        for (i = 0; i < sections.length; i++) {\n            const isv4 = isV4(sections[i]);\n            let v4Buffer;\n            if (isv4) {\n                v4Buffer = toBytes(sections[i]);\n                sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16');\n            }\n            if (v4Buffer != null && ++i < 8) {\n                sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'));\n            }\n        }\n        if (sections[0] === '') {\n            while (sections.length < 8)\n                sections.unshift('0');\n        }\n        else if (sections[sections.length - 1] === '') {\n            while (sections.length < 8)\n                sections.push('0');\n        }\n        else if (sections.length < 8) {\n            for (i = 0; i < sections.length && sections[i] !== ''; i++)\n                ;\n            const argv = [i, 1];\n            for (i = 9 - sections.length; i > 0; i--) {\n                argv.push('0');\n            }\n            sections.splice.apply(sections, argv);\n        }\n        const bytes = new Uint8Array(offset + 16);\n        for (i = 0; i < sections.length; i++) {\n            const word = parseInt(sections[i], 16);\n            bytes[offset++] = (word >> 8) & 0xff;\n            bytes[offset++] = word & 0xff;\n        }\n        return bytes;\n    }\n    throw new Error('invalid ip address');\n};\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const toString = function (buf, offset = 0, length) {\n    offset = ~~offset;\n    length = length ?? (buf.length - offset);\n    const view = new DataView(buf.buffer);\n    if (length === 4) {\n        const result = [];\n        // IPv4\n        for (let i = 0; i < length; i++) {\n            result.push(buf[offset + i]);\n        }\n        return result.join('.');\n    }\n    if (length === 16) {\n        const result = [];\n        // IPv6\n        for (let i = 0; i < length; i += 2) {\n            result.push(view.getUint16(offset + i).toString(16));\n        }\n        return result.join(':')\n            .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n            .replace(/:{3,4}/, '::');\n    }\n    return '';\n};\n//# sourceMappingURL=ip.js.map","const V = -1;\nexport const names = {};\nexport const codes = {};\nexport const table = [\n    [4, 32, 'ip4'],\n    [6, 16, 'tcp'],\n    [33, 16, 'dccp'],\n    [41, 128, 'ip6'],\n    [42, V, 'ip6zone'],\n    [43, 8, 'ipcidr'],\n    [53, V, 'dns', true],\n    [54, V, 'dns4', true],\n    [55, V, 'dns6', true],\n    [56, V, 'dnsaddr', true],\n    [132, 16, 'sctp'],\n    [273, 16, 'udp'],\n    [275, 0, 'p2p-webrtc-star'],\n    [276, 0, 'p2p-webrtc-direct'],\n    [277, 0, 'p2p-stardust'],\n    [280, 0, 'webrtc-direct'],\n    [281, 0, 'webrtc'],\n    [290, 0, 'p2p-circuit'],\n    [301, 0, 'udt'],\n    [302, 0, 'utp'],\n    [400, V, 'unix', false, true],\n    // `ipfs` is added before `p2p` for legacy support.\n    // All text representations will default to `p2p`, but `ipfs` will\n    // still be supported\n    [421, V, 'ipfs'],\n    // `p2p` is the preferred name for 421, and is now the default\n    [421, V, 'p2p'],\n    [443, 0, 'https'],\n    [444, 96, 'onion'],\n    [445, 296, 'onion3'],\n    [446, V, 'garlic64'],\n    [448, 0, 'tls'],\n    [449, V, 'sni'],\n    [460, 0, 'quic'],\n    [461, 0, 'quic-v1'],\n    [465, 0, 'webtransport'],\n    [466, V, 'certhash'],\n    [477, 0, 'ws'],\n    [478, 0, 'wss'],\n    [479, 0, 'p2p-websocket-star'],\n    [480, 0, 'http'],\n    [481, V, 'http-path'],\n    [777, V, 'memory']\n];\n// populate tables\ntable.forEach(row => {\n    const proto = createProtocol(...row);\n    codes[proto.code] = proto;\n    names[proto.name] = proto;\n});\nexport function createProtocol(code, size, name, resolvable, path) {\n    return {\n        code,\n        size,\n        name,\n        resolvable: Boolean(resolvable),\n        path: Boolean(path)\n    };\n}\n/**\n * For the passed proto string or number, return a {@link Protocol}\n *\n * @example\n *\n * ```js\n * import { protocol } from '@multiformats/multiaddr'\n *\n * console.info(protocol(4))\n * // { code: 4, size: 32, name: 'ip4', resolvable: false, path: false }\n * ```\n */\nexport function getProtocol(proto) {\n    if (typeof proto === 'number') {\n        if (codes[proto] != null) {\n            return codes[proto];\n        }\n        throw new Error(`no protocol with code: ${proto}`);\n    }\n    else if (typeof proto === 'string') {\n        if (names[proto] != null) {\n            return names[proto];\n        }\n        throw new Error(`no protocol with name: ${proto}`);\n    }\n    throw new Error(`invalid protocol id type: ${typeof proto}`);\n}\n//# sourceMappingURL=protocols-table.js.map","/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n    if (a instanceof Uint8Array) {\n        return convertToString(proto, a);\n    }\n    else {\n        return convertToBytes(proto, a);\n    }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString(proto, buf) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n        case 41: // ipv6\n            return bytes2ip(buf);\n        case 42: // ipv6zone\n            return bytes2str(buf);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return bytes2port(buf).toString();\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return bytes2str(buf);\n        case 421: // ipfs\n            return bytes2mh(buf);\n        case 444: // onion\n            return bytes2onion(buf);\n        case 445: // onion3\n            return bytes2onion(buf);\n        case 466: // certhash\n            return bytes2mb(buf);\n        case 481: // http-path\n            return globalThis.encodeURIComponent(bytes2str(buf));\n        default:\n            return uint8ArrayToString(buf, 'base16'); // no clue. convert to hex\n    }\n}\nexport function convertToBytes(proto, str) {\n    const protocol = getProtocol(proto);\n    switch (protocol.code) {\n        case 4: // ipv4\n            return ip2bytes(str);\n        case 41: // ipv6\n            return ip2bytes(str);\n        case 42: // ipv6zone\n            return str2bytes(str);\n        case 6: // tcp\n        case 273: // udp\n        case 33: // dccp\n        case 132: // sctp\n            return port2bytes(parseInt(str, 10));\n        case 53: // dns\n        case 54: // dns4\n        case 55: // dns6\n        case 56: // dnsaddr\n        case 400: // unix\n        case 449: // sni\n        case 777: // memory\n            return str2bytes(str);\n        case 421: // ipfs\n            return mh2bytes(str);\n        case 444: // onion\n            return onion2bytes(str);\n        case 445: // onion3\n            return onion32bytes(str);\n        case 466: // certhash\n            return mb2bytes(str);\n        case 481: // http-path\n            return str2bytes(globalThis.decodeURIComponent(str));\n        default:\n            return uint8ArrayFromString(str, 'base16'); // no clue. convert from hex\n    }\n}\nexport function convertToIpNet(multiaddr) {\n    let mask;\n    let addr;\n    multiaddr.stringTuples().forEach(([code, value]) => {\n        if (code === ip4Protocol.code || code === ip6Protocol.code) {\n            addr = value;\n        }\n        if (code === ipcidrProtocol.code) {\n            mask = value;\n        }\n    });\n    if (mask == null || addr == null) {\n        throw new Error('Invalid multiaddr');\n    }\n    return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map((c) => c.decoder);\nconst anybaseDecoder = (function () {\n    let acc = decoders[0].or(decoders[1]);\n    decoders.slice(2).forEach((d) => (acc = acc.or(d)));\n    return acc;\n})();\nfunction ip2bytes(ipString) {\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n    const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n    if (ipString == null) {\n        throw new Error('ipBuff is required');\n    }\n    if (!ip.isIP(ipString)) {\n        throw new Error('invalid ip address');\n    }\n    return ipString;\n}\nfunction port2bytes(port) {\n    const buf = new ArrayBuffer(2);\n    const view = new DataView(buf);\n    view.setUint16(0, port);\n    return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n    const view = new DataView(buf.buffer);\n    return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n    const buf = uint8ArrayFromString(str);\n    const size = Uint8Array.from(varint.encode(buf.length));\n    return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n    const size = varint.decode(buf);\n    buf = buf.slice(varint.encodingLength(size));\n    if (buf.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n    let mh;\n    if (hash[0] === 'Q' || hash[0] === '1') {\n        mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n    }\n    else {\n        mh = CID.parse(hash).multihash.bytes;\n    }\n    // the address is a varint prefixed multihash string representation\n    const size = Uint8Array.from(varint.encode(mh.length));\n    return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n    const mb = anybaseDecoder.decode(mbstr);\n    const size = Uint8Array.from(varint.encode(mb.length));\n    return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n    const size = varint.decode(buf);\n    const hash = buf.slice(varint.encodingLength(size));\n    if (hash.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n    const size = varint.decode(buf);\n    const address = buf.slice(varint.encodingLength(size));\n    if (address.length !== size) {\n        throw new Error('inconsistent lengths');\n    }\n    return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 16) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode('b' + addr[0]);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n    const addr = str.split(':');\n    if (addr.length !== 2) {\n        throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n    }\n    if (addr[0].length !== 56) {\n        throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n    }\n    // onion addresses do not include the multibase prefix, add it before decoding\n    const buf = base32.decode(`b${addr[0]}`);\n    // onion port number\n    const port = parseInt(addr[1], 10);\n    if (port < 1 || port > 65536) {\n        throw new Error('Port number is not in range(1, 65536)');\n    }\n    const portBuf = port2bytes(port);\n    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n    const addrBytes = buf.slice(0, buf.length - 2);\n    const portBytes = buf.slice(buf.length - 2);\n    const addr = uint8ArrayToString(addrBytes, 'base32');\n    const port = bytes2port(portBytes);\n    return `${addr}:${port}`;\n}\n//# sourceMappingURL=convert.js.map","import * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { convertToBytes, convertToString } from './convert.js';\nimport { getProtocol } from './protocols-table.js';\nexport function stringToMultiaddrParts(str) {\n    str = cleanPath(str);\n    const tuples = [];\n    const stringTuples = [];\n    let path = null;\n    const parts = str.split('/').slice(1);\n    if (parts.length === 1 && parts[0] === '') {\n        return {\n            bytes: new Uint8Array(),\n            string: '/',\n            tuples: [],\n            stringTuples: [],\n            path: null\n        };\n    }\n    for (let p = 0; p < parts.length; p++) {\n        const part = parts[p];\n        const proto = getProtocol(part);\n        if (proto.size === 0) {\n            tuples.push([proto.code]);\n            stringTuples.push([proto.code]);\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        p++; // advance addr part\n        if (p >= parts.length) {\n            throw ParseError('invalid address: ' + str);\n        }\n        // if it's a path proto, take the rest\n        if (proto.path === true) {\n            // should we need to check each path part to see if it's a proto?\n            // This would allow for other protocols to be added after a unix path,\n            // however it would have issues if the path had a protocol name in the path\n            path = cleanPath(parts.slice(p).join('/'));\n            tuples.push([proto.code, convertToBytes(proto.code, path)]);\n            stringTuples.push([proto.code, path]);\n            break;\n        }\n        const bytes = convertToBytes(proto.code, parts[p]);\n        tuples.push([proto.code, bytes]);\n        stringTuples.push([proto.code, convertToString(proto.code, bytes)]);\n    }\n    return {\n        string: stringTuplesToString(stringTuples),\n        bytes: tuplesToBytes(tuples),\n        tuples,\n        stringTuples,\n        path\n    };\n}\nexport function bytesToMultiaddrParts(bytes) {\n    const tuples = [];\n    const stringTuples = [];\n    let path = null;\n    let i = 0;\n    while (i < bytes.length) {\n        const code = varint.decode(bytes, i);\n        const n = varint.encodingLength(code);\n        const p = getProtocol(code);\n        const size = sizeForAddr(p, bytes.slice(i + n));\n        if (size === 0) {\n            tuples.push([code]);\n            stringTuples.push([code]);\n            i += n;\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        const addr = bytes.slice(i + n, i + n + size);\n        i += (size + n);\n        if (i > bytes.length) { // did not end _exactly_ at buffer.length\n            throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(bytes, 'base16'));\n        }\n        // ok, tuple seems good.\n        tuples.push([code, addr]);\n        const stringAddr = convertToString(code, addr);\n        stringTuples.push([code, stringAddr]);\n        if (p.path === true) {\n            // should we need to check each path part to see if it's a proto?\n            // This would allow for other protocols to be added after a unix path,\n            // however it would have issues if the path had a protocol name in the path\n            path = stringAddr;\n            break;\n        }\n    }\n    return {\n        bytes: Uint8Array.from(bytes),\n        string: stringTuplesToString(stringTuples),\n        tuples,\n        stringTuples,\n        path\n    };\n}\n/**\n * [[str name, str addr]... ] -> string\n */\nfunction stringTuplesToString(tuples) {\n    const parts = [];\n    tuples.map((tup) => {\n        const proto = getProtocol(tup[0]);\n        parts.push(proto.name);\n        if (tup.length > 1 && tup[1] != null) {\n            parts.push(tup[1]);\n        }\n        return null;\n    });\n    return cleanPath(parts.join('/'));\n}\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nexport function tuplesToBytes(tuples) {\n    return uint8ArrayConcat(tuples.map((tup) => {\n        const proto = getProtocol(tup[0]);\n        let buf = Uint8Array.from(varint.encode(proto.code));\n        if (tup.length > 1 && tup[1] != null) {\n            buf = uint8ArrayConcat([buf, tup[1]]); // add address buffer\n        }\n        return buf;\n    }));\n}\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr(p, addr) {\n    if (p.size > 0) {\n        return p.size / 8;\n    }\n    else if (p.size === 0) {\n        return 0;\n    }\n    else {\n        const size = varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));\n        return size + varint.encodingLength(size);\n    }\n}\nexport function bytesToTuples(buf) {\n    const tuples = [];\n    let i = 0;\n    while (i < buf.length) {\n        const code = varint.decode(buf, i);\n        const n = varint.encodingLength(code);\n        const p = getProtocol(code);\n        const size = sizeForAddr(p, buf.slice(i + n));\n        if (size === 0) {\n            tuples.push([code]);\n            i += n;\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        const addr = buf.slice(i + n, i + n + size);\n        i += (size + n);\n        if (i > buf.length) { // did not end _exactly_ at buffer.length\n            throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'));\n        }\n        // ok, tuple seems good.\n        tuples.push([code, addr]);\n    }\n    return tuples;\n}\nexport function cleanPath(str) {\n    return '/' + str.trim().split('/').filter((a) => a).join('/');\n}\nexport function ParseError(str) {\n    return new Error('Error parsing address: ' + str);\n}\n//# sourceMappingURL=codec.js.map","/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\nimport { CodeError } from '@libp2p/interface';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, tuplesToBytes } from './codec.js';\nimport { getProtocol, names } from './protocols-table.js';\nimport { isMultiaddr, multiaddr, resolvers } from './index.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr');\nconst DNS_CODES = [\n    getProtocol('dns').code,\n    getProtocol('dns4').code,\n    getProtocol('dns6').code,\n    getProtocol('dnsaddr').code\n];\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr {\n    bytes;\n    #string;\n    #tuples;\n    #stringTuples;\n    #path;\n    [symbol] = true;\n    constructor(addr) {\n        // default\n        if (addr == null) {\n            addr = '';\n        }\n        let parts;\n        if (addr instanceof Uint8Array) {\n            parts = bytesToMultiaddrParts(addr);\n        }\n        else if (typeof addr === 'string') {\n            if (addr.length > 0 && addr.charAt(0) !== '/') {\n                throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`);\n            }\n            parts = stringToMultiaddrParts(addr);\n        }\n        else if (isMultiaddr(addr)) { // Multiaddr\n            parts = bytesToMultiaddrParts(addr.bytes);\n        }\n        else {\n            throw new Error('addr must be a string, Buffer, or another Multiaddr');\n        }\n        this.bytes = parts.bytes;\n        this.#string = parts.string;\n        this.#tuples = parts.tuples;\n        this.#stringTuples = parts.stringTuples;\n        this.#path = parts.path;\n    }\n    toString() {\n        return this.#string;\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toOptions() {\n        let family;\n        let transport;\n        let host;\n        let port;\n        let zone = '';\n        const tcp = getProtocol('tcp');\n        const udp = getProtocol('udp');\n        const ip4 = getProtocol('ip4');\n        const ip6 = getProtocol('ip6');\n        const dns6 = getProtocol('dns6');\n        const ip6zone = getProtocol('ip6zone');\n        for (const [code, value] of this.stringTuples()) {\n            if (code === ip6zone.code) {\n                zone = `%${value ?? ''}`;\n            }\n            // default to https when protocol & port are omitted from DNS addrs\n            if (DNS_CODES.includes(code)) {\n                transport = tcp.name;\n                port = 443;\n                host = `${value ?? ''}${zone}`;\n                family = code === dns6.code ? 6 : 4;\n            }\n            if (code === tcp.code || code === udp.code) {\n                transport = getProtocol(code).name;\n                port = parseInt(value ?? '');\n            }\n            if (code === ip4.code || code === ip6.code) {\n                transport = getProtocol(code).name;\n                host = `${value ?? ''}${zone}`;\n                family = code === ip6.code ? 6 : 4;\n            }\n        }\n        if (family == null || transport == null || host == null || port == null) {\n            throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n        }\n        const opts = {\n            family,\n            host,\n            transport,\n            port\n        };\n        return opts;\n    }\n    protos() {\n        return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)));\n    }\n    protoCodes() {\n        return this.#tuples.map(([code]) => code);\n    }\n    protoNames() {\n        return this.#tuples.map(([code]) => getProtocol(code).name);\n    }\n    tuples() {\n        return this.#tuples;\n    }\n    stringTuples() {\n        return this.#stringTuples;\n    }\n    encapsulate(addr) {\n        addr = new Multiaddr(addr);\n        return new Multiaddr(this.toString() + addr.toString());\n    }\n    decapsulate(addr) {\n        const addrString = addr.toString();\n        const s = this.toString();\n        const i = s.lastIndexOf(addrString);\n        if (i < 0) {\n            throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n        }\n        return new Multiaddr(s.slice(0, i));\n    }\n    decapsulateCode(code) {\n        const tuples = this.tuples();\n        for (let i = tuples.length - 1; i >= 0; i--) {\n            if (tuples[i][0] === code) {\n                return new Multiaddr(tuplesToBytes(tuples.slice(0, i)));\n            }\n        }\n        return this;\n    }\n    getPeerId() {\n        try {\n            let tuples = [];\n            this.stringTuples().forEach(([code, name]) => {\n                if (code === names.p2p.code) {\n                    tuples.push([code, name]);\n                }\n                // if this is a p2p-circuit address, return the target peer id if present\n                // not the peer id of the relay\n                if (code === names['p2p-circuit'].code) {\n                    tuples = [];\n                }\n            });\n            // Get the last ipfs tuple ['p2p', 'peerid string']\n            const tuple = tuples.pop();\n            if (tuple?.[1] != null) {\n                const peerIdStr = tuple[1];\n                // peer id is base58btc encoded string but not multibase encoded so add the `z`\n                // prefix so we can validate that it is correctly encoded\n                if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n                    return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n                }\n                // try to parse peer id as CID\n                return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    getPath() {\n        return this.#path;\n    }\n    equals(addr) {\n        return uint8ArrayEquals(this.bytes, addr.bytes);\n    }\n    async resolve(options) {\n        const resolvableProto = this.protos().find((p) => p.resolvable);\n        // Multiaddr is not resolvable?\n        if (resolvableProto == null) {\n            return [this];\n        }\n        const resolver = resolvers.get(resolvableProto.name);\n        if (resolver == null) {\n            throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER');\n        }\n        const result = await resolver(this, options);\n        return result.map(str => multiaddr(str));\n    }\n    nodeAddress() {\n        const options = this.toOptions();\n        if (options.transport !== 'tcp' && options.transport !== 'udp') {\n            throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n        }\n        return {\n            family: options.family,\n            address: options.host,\n            port: options.port\n        };\n    }\n    isThinWaistAddress(addr) {\n        const protos = (addr ?? this).protos();\n        if (protos.length !== 2) {\n            return false;\n        }\n        if (protos[0].code !== 4 && protos[0].code !== 41) {\n            return false;\n        }\n        if (protos[1].code !== 6 && protos[1].code !== 273) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns Multiaddr as a human-readable string\n     * https://nodejs.org/api/util.html#utilinspectcustom\n     *\n     * @example\n     * ```js\n     * import { multiaddr } from '@multiformats/multiaddr'\n     *\n     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n     * ```\n     */\n    [inspect]() {\n        return `Multiaddr(${this.#string})`;\n    }\n}\n//# sourceMappingURL=multiaddr.js.map","/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * const addr =  multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * const addr = multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddr } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddr)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(await ma.resolve(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n */\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js';\nimport { getProtocol } from './protocols-table.js';\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map();\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js';\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress(addr, transport) {\n    if (addr == null) {\n        throw new Error('requires node address object');\n    }\n    if (transport == null) {\n        throw new Error('requires transport protocol');\n    }\n    let ip;\n    let host = addr.address;\n    switch (addr.family) {\n        case 4:\n            ip = 'ip4';\n            break;\n        case 6:\n            ip = 'ip6';\n            if (host.includes('%')) {\n                const parts = host.split('%');\n                if (parts.length !== 2) {\n                    throw Error('Multiple ip6 zones in multiaddr');\n                }\n                host = parts[0];\n                const zone = parts[1];\n                ip = `/ip6zone/${zone}/ip6`;\n            }\n            break;\n        default:\n            throw Error('Invalid addr family, should be 4 or 6.');\n    }\n    return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'));\n}\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName(addr) {\n    if (!isMultiaddr(addr)) {\n        return false;\n    }\n    // if a part of the multiaddr is resolvable, then return true\n    return addr.protos().some((proto) => proto.resolvable);\n}\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr(value) {\n    return Boolean(value?.[symbol]);\n}\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr(addr) {\n    return new MultiaddrClass(addr);\n}\nexport { getProtocol as protocols };\n//# sourceMappingURL=index.js.map","/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=equals.js.map","import { multiaddr } from '@multiformats/multiaddr';\n/*\n * Valid combinations\n */\nexport const DNS4 = base('dns4');\nexport const DNS6 = base('dns6');\nexport const DNSADDR = base('dnsaddr');\nexport const DNS = or(base('dns'), DNSADDR, DNS4, DNS6);\nexport const IP = or(base('ip4'), base('ip6'));\nexport const TCP = or(and(IP, base('tcp')), and(DNS, base('tcp')));\nexport const UDP = and(IP, base('udp'));\nexport const UTP = and(UDP, base('utp'));\nexport const QUIC = and(UDP, base('quic'));\nexport const QUICV1 = and(UDP, base('quic-v1'));\nconst _WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));\nexport const WebSockets = or(and(_WebSockets, base('p2p')), _WebSockets);\nconst _WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')), and(TCP, base('tls'), base('ws')), and(DNS, base('tls'), base('ws')));\nexport const WebSocketsSecure = or(and(_WebSocketsSecure, base('p2p')), _WebSocketsSecure);\nexport const HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')));\nexport const HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));\nconst _WebRTCDirect = and(UDP, base('webrtc-direct'), base('certhash'));\nexport const WebRTCDirect = or(and(_WebRTCDirect, base('p2p')), _WebRTCDirect);\nconst _WebTransport = and(QUICV1, base('webtransport'), base('certhash'), base('certhash'));\nexport const WebTransport = or(and(_WebTransport, base('p2p')), _WebTransport);\n/**\n * @deprecated\n */\nexport const P2PWebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('p2p')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')), and(WebSockets, base('p2p-webrtc-star')), and(WebSocketsSecure, base('p2p-webrtc-star')));\nexport const WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('p2p')), and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));\n/**\n * @deprecated\n */\nexport const P2PWebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct'), base('p2p')), and(HTTPS, base('p2p-webrtc-direct'), base('p2p')), and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));\nexport const Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);\n// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\nexport const Stardust = or(and(Reliable, base('p2p-stardust'), base('p2p')), and(Reliable, base('p2p-stardust')));\nconst _P2P = or(and(Reliable, base('p2p')), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base('p2p'));\nconst _Circuit = or(and(_P2P, base('p2p-circuit'), _P2P), and(_P2P, base('p2p-circuit')), and(base('p2p-circuit'), _P2P), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));\nconst CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);\nexport const Circuit = CircuitRecursive();\nexport const P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);\nexport const IPFS = P2P;\nexport const WebRTC = or(and(Circuit, base('webrtc'), base('p2p')), and(Circuit, base('webrtc')), and(Reliable, base('webrtc'), base('p2p')), and(Reliable, base('webrtc')), base('webrtc'));\n/*\n * Validation funcs\n */\nfunction makeMatchesFunction(partialMatch) {\n    function matches(a) {\n        let ma;\n        try {\n            ma = multiaddr(a);\n        }\n        catch (err) { // catch error\n            return false; // also if it's invalid it's probably not matching as well so return false\n        }\n        const out = partialMatch(ma.protoNames());\n        if (out === null) {\n            return false;\n        }\n        if (out === true || out === false) {\n            return out;\n        }\n        return out.length === 0;\n    }\n    return matches;\n}\nfunction and(...args) {\n    function partialMatch(a) {\n        if (a.length < args.length) {\n            return null;\n        }\n        let out = a;\n        args.some((arg) => {\n            out = typeof arg === 'function'\n                ? arg().partialMatch(a)\n                : arg.partialMatch(a);\n            if (Array.isArray(out)) {\n                a = out;\n            }\n            if (out === null) {\n                return true;\n            }\n            return false;\n        });\n        return out;\n    }\n    return {\n        toString: function () { return '{ ' + args.join(' ') + ' }'; },\n        input: args,\n        matches: makeMatchesFunction(partialMatch),\n        partialMatch\n    };\n}\nfunction or(...args) {\n    function partialMatch(a) {\n        let out = null;\n        args.some((arg) => {\n            const res = typeof arg === 'function'\n                ? arg().partialMatch(a)\n                : arg.partialMatch(a);\n            if (res != null) {\n                out = res;\n                return true;\n            }\n            return false;\n        });\n        return out;\n    }\n    const result = {\n        toString: function () { return '{ ' + args.join(' ') + ' }'; },\n        input: args,\n        matches: makeMatchesFunction(partialMatch),\n        partialMatch\n    };\n    return result;\n}\nfunction base(n) {\n    const name = n;\n    function matches(a) {\n        let ma;\n        try {\n            ma = multiaddr(a);\n        }\n        catch (err) { // catch error\n            return false; // also if it's invalid it's probably not matching as well so return false\n        }\n        const pnames = ma.protoNames();\n        if (pnames.length === 1 && pnames[0] === name) {\n            return true;\n        }\n        return false;\n    }\n    function partialMatch(protos) {\n        if (protos.length === 0) {\n            return null;\n        }\n        if (protos[0] === name) {\n            return protos.slice(1);\n        }\n        return null;\n    }\n    return {\n        toString: function () { return name; },\n        matches,\n        partialMatch\n    };\n}\n//# sourceMappingURL=index.js.map","export const empty = new Uint8Array(0);\nexport function toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nexport function fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nexport function equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nexport function isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nexport function fromString(str) {\n    return new TextEncoder().encode(str);\n}\nexport function toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map","/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;\n//# sourceMappingURL=base-x.js.map","import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        /* c8 ignore next 3 */\n        if (prefix.codePointAt(0) === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefix.codePointAt(0);\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nexport function or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nexport class Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nexport function from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = basex(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => coerce(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n    prefix: 'b',\n    name: 'base32',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n    bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n    prefix: 'B',\n    name: 'base32upper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n    bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n    prefix: 'c',\n    name: 'base32pad',\n    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n    bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n    prefix: 'C',\n    name: 'base32padupper',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n    prefix: 'v',\n    name: 'base32hex',\n    alphabet: '0123456789abcdefghijklmnopqrstuv',\n    bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n    prefix: 'V',\n    name: 'base32hexupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n    bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n    prefix: 't',\n    name: 'base32hexpad',\n    alphabet: '0123456789abcdefghijklmnopqrstuv=',\n    bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n    prefix: 'T',\n    name: 'base32hexpadupper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n    prefix: 'h',\n    name: 'base32z',\n    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n    bitsPerChar: 5\n});\n//# sourceMappingURL=base32.js.map","import { baseX } from './base.js';\nexport const base58btc = baseX({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map","/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;\n//# sourceMappingURL=varint.js.map","import varint from './vendor/varint.js';\nexport function decode(data, offset = 0) {\n    const code = varint.decode(data, offset);\n    return [code, varint.decode.bytes];\n}\nexport function encodeTo(int, target, offset = 0) {\n    varint.encode(int, target, offset);\n    return target;\n}\nexport function encodingLength(int) {\n    return varint.encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map","import { coerce, equals as equalBytes } from '../bytes.js';\nimport * as varint from '../varint.js';\n/**\n * Creates a multihash digest.\n */\nexport function create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = varint.encodingLength(code);\n    const digestOffset = sizeOffset + varint.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    varint.encodeTo(code, bytes, 0);\n    varint.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode(multihash) {\n    const bytes = coerce(multihash);\n    const [code, sizeOffset] = varint.decode(bytes);\n    const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nexport function equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            equalBytes(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n//# sourceMappingURL=digest.js.map","import { base32 } from './bases/base32.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nexport function format(link, base) {\n    const { bytes, version } = link;\n    switch (version) {\n        case 0:\n            return toStringV0(bytes, baseCache(link), base ?? base58btc.encoder);\n        default:\n            return toStringV1(bytes, baseCache(link), (base ?? base32.encoder));\n    }\n}\nexport function toJSON(link) {\n    return {\n        '/': format(link)\n    };\n}\nexport function fromJSON(json) {\n    return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n    const baseCache = cache.get(cid);\n    if (baseCache == null) {\n        const baseCache = new Map();\n        cache.set(cid, baseCache);\n        return baseCache;\n    }\n    return baseCache;\n}\nexport class CID {\n    code;\n    version;\n    multihash;\n    bytes;\n    '/';\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param multihash - (Multi)hash of the of the content.\n     */\n    constructor(version, code, multihash, bytes) {\n        this.code = code;\n        this.version = version;\n        this.multihash = multihash;\n        this.bytes = bytes;\n        // flag to serializers that this is a CID and\n        // should be treated specially\n        this['/'] = bytes;\n    }\n    /**\n     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n     * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n     *\n     * @deprecated\n     */\n    get asCID() {\n        return this;\n    }\n    // ArrayBufferView\n    get byteOffset() {\n        return this.bytes.byteOffset;\n    }\n    // ArrayBufferView\n    get byteLength() {\n        return this.bytes.byteLength;\n    }\n    toV0() {\n        switch (this.version) {\n            case 0: {\n                return this;\n            }\n            case 1: {\n                const { code, multihash } = this;\n                if (code !== DAG_PB_CODE) {\n                    throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n                }\n                // sha2-256\n                if (multihash.code !== SHA_256_CODE) {\n                    throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n                }\n                return (CID.createV0(multihash));\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n            }\n        }\n    }\n    toV1() {\n        switch (this.version) {\n            case 0: {\n                const { code, digest } = this.multihash;\n                const multihash = Digest.create(code, digest);\n                return (CID.createV1(this.code, multihash));\n            }\n            case 1: {\n                return this;\n            }\n            default: {\n                throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n            }\n        }\n    }\n    equals(other) {\n        return CID.equals(this, other);\n    }\n    static equals(self, other) {\n        const unknown = other;\n        return (unknown != null &&\n            self.code === unknown.code &&\n            self.version === unknown.version &&\n            Digest.equals(self.multihash, unknown.multihash));\n    }\n    toString(base) {\n        return format(this, base);\n    }\n    toJSON() {\n        return { '/': format(this) };\n    }\n    link() {\n        return this;\n    }\n    [Symbol.toStringTag] = 'CID';\n    // Legacy\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return `CID(${this.toString()})`;\n    }\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returns null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     */\n    static asCID(input) {\n        if (input == null) {\n            return null;\n        }\n        const value = input;\n        if (value instanceof CID) {\n            // If value is instance of CID then we're all set.\n            return value;\n        }\n        else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n            // If value isn't instance of this CID class but `this.asCID === this` or\n            // `value['/'] === value.bytes` is true it is CID instance coming from a\n            // different implementation (diff version or duplicate). In that case we\n            // rebase it to this `CID` implementation so caller is guaranteed to get\n            // instance with expected API.\n            const { version, code, multihash, bytes } = value;\n            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n        }\n        else if (value[cidSymbol] === true) {\n            // If value is a CID from older implementation that used to be tagged via\n            // symbol we still rebase it to the this `CID` implementation by\n            // delegating that to a constructor.\n            const { version, multihash, code } = value;\n            const digest = Digest.decode(multihash);\n            return CID.create(version, code, digest);\n        }\n        else {\n            // Otherwise value is not a CID (or an incompatible version of it) in\n            // which case we return `null`.\n            return null;\n        }\n    }\n    /**\n     * @param version - Version of the CID\n     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param digest - (Multi)hash of the of the content.\n     */\n    static create(version, code, digest) {\n        if (typeof code !== 'number') {\n            throw new Error('String codecs are no longer supported');\n        }\n        if (!(digest.bytes instanceof Uint8Array)) {\n            throw new Error('Invalid digest');\n        }\n        switch (version) {\n            case 0: {\n                if (code !== DAG_PB_CODE) {\n                    throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n                }\n                else {\n                    return new CID(version, code, digest, digest.bytes);\n                }\n            }\n            case 1: {\n                const bytes = encodeCID(version, code, digest.bytes);\n                return new CID(version, code, digest, bytes);\n            }\n            default: {\n                throw new Error('Invalid version');\n            }\n        }\n    }\n    /**\n     * Simplified version of `create` for CIDv0.\n     */\n    static createV0(digest) {\n        return CID.create(0, DAG_PB_CODE, digest);\n    }\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @param code - Content encoding format code.\n     * @param digest - Multihash of the content.\n     */\n    static createV1(code, digest) {\n        return CID.create(1, code, digest);\n    }\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     */\n    static decode(bytes) {\n        const [cid, remainder] = CID.decodeFirst(bytes);\n        if (remainder.length !== 0) {\n            throw new Error('Incorrect length');\n        }\n        return cid;\n    }\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     */\n    static decodeFirst(bytes) {\n        const specs = CID.inspectBytes(bytes);\n        const prefixSize = specs.size - specs.multihashSize;\n        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n        if (multihashBytes.byteLength !== specs.multihashSize) {\n            throw new Error('Incorrect length');\n        }\n        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n        const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n        const cid = specs.version === 0\n            ? CID.createV0(digest)\n            : CID.createV1(specs.codec, digest);\n        return [cid, bytes.subarray(specs.size)];\n    }\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     */\n    static inspectBytes(initialBytes) {\n        let offset = 0;\n        const next = () => {\n            const [i, length] = varint.decode(initialBytes.subarray(offset));\n            offset += length;\n            return i;\n        };\n        let version = next();\n        let codec = DAG_PB_CODE;\n        if (version === 18) {\n            // CIDv0\n            version = 0;\n            offset = 0;\n        }\n        else {\n            codec = next();\n        }\n        if (version !== 0 && version !== 1) {\n            throw new RangeError(`Invalid CID version ${version}`);\n        }\n        const prefixSize = offset;\n        const multihashCode = next(); // multihash code\n        const digestSize = next(); // multihash length\n        const size = offset + digestSize;\n        const multihashSize = size - prefixSize;\n        return { version, codec, multihashCode, digestSize, multihashSize, size };\n    }\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     */\n    static parse(source, base) {\n        const [prefix, bytes] = parseCIDtoBytes(source, base);\n        const cid = CID.decode(bytes);\n        if (cid.version === 0 && source[0] !== 'Q') {\n            throw Error('Version 0 CID string must not include multibase prefix');\n        }\n        // Cache string representation to avoid computing it on `this.toString()`\n        baseCache(cid).set(prefix, source);\n        return cid;\n    }\n}\nfunction parseCIDtoBytes(source, base) {\n    switch (source[0]) {\n        // CIDv0 is parsed differently\n        case 'Q': {\n            const decoder = base ?? base58btc;\n            return [\n                base58btc.prefix,\n                decoder.decode(`${base58btc.prefix}${source}`)\n            ];\n        }\n        case base58btc.prefix: {\n            const decoder = base ?? base58btc;\n            return [base58btc.prefix, decoder.decode(source)];\n        }\n        case base32.prefix: {\n            const decoder = base ?? base32;\n            return [base32.prefix, decoder.decode(source)];\n        }\n        default: {\n            if (base == null) {\n                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n            }\n            return [source[0], base.decode(source)];\n        }\n    }\n}\nfunction toStringV0(bytes, cache, base) {\n    const { prefix } = base;\n    if (prefix !== base58btc.prefix) {\n        throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n    }\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes).slice(1);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nfunction toStringV1(bytes, cache, base) {\n    const { prefix } = base;\n    const cid = cache.get(prefix);\n    if (cid == null) {\n        const cid = base.encode(bytes);\n        cache.set(prefix, cid);\n        return cid;\n    }\n    else {\n        return cid;\n    }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n    const codeOffset = varint.encodingLength(version);\n    const hashOffset = codeOffset + varint.encodingLength(code);\n    const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n    varint.encodeTo(version, bytes, 0);\n    varint.encodeTo(code, bytes, codeOffset);\n    bytes.set(multihash, hashOffset);\n    return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\n//# sourceMappingURL=cid.js.map","import { baseX } from './base.js';\nexport const base10 = baseX({\n    prefix: '9',\n    name: 'base10',\n    alphabet: '0123456789'\n});\n//# sourceMappingURL=base10.js.map","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n    prefix: 'f',\n    name: 'base16',\n    alphabet: '0123456789abcdef',\n    bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n    prefix: 'F',\n    name: 'base16upper',\n    alphabet: '0123456789ABCDEF',\n    bitsPerChar: 4\n});\n//# sourceMappingURL=base16.js.map","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n    prefix: '0',\n    name: 'base2',\n    alphabet: '01',\n    bitsPerChar: 1\n});\n//# sourceMappingURL=base2.js.map","import { from } from './base.js';\nconst alphabet = Array.from('🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂');\nconst alphabetBytesToChars = (alphabet.reduce((p, c, i) => { p[i] = c; return p; }, ([])));\nconst alphabetCharsToBytes = (alphabet.reduce((p, c, i) => { p[c.codePointAt(0)] = i; return p; }, ([])));\nfunction encode(data) {\n    return data.reduce((p, c) => {\n        p += alphabetBytesToChars[c];\n        return p;\n    }, '');\n}\nfunction decode(str) {\n    const byts = [];\n    for (const char of str) {\n        const byt = alphabetCharsToBytes[char.codePointAt(0)];\n        if (byt === undefined) {\n            throw new Error(`Non-base256emoji character: ${char}`);\n        }\n        byts.push(byt);\n    }\n    return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n    prefix: '🚀',\n    name: 'base256emoji',\n    encode,\n    decode\n});\n//# sourceMappingURL=base256emoji.js.map","import { baseX } from './base.js';\nexport const base36 = baseX({\n    prefix: 'k',\n    name: 'base36',\n    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n    prefix: 'K',\n    name: 'base36upper',\n    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base36.js.map","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n    prefix: 'm',\n    name: 'base64',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n    prefix: 'M',\n    name: 'base64pad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n    prefix: 'u',\n    name: 'base64url',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n    bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n    prefix: 'U',\n    name: 'base64urlpad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n    bitsPerChar: 6\n});\n//# sourceMappingURL=base64.js.map","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n    prefix: '7',\n    name: 'base8',\n    alphabet: '01234567',\n    bitsPerChar: 3\n});\n//# sourceMappingURL=base8.js.map","import { fromString, toString } from '../bytes.js';\nimport { from } from './base.js';\nexport const identity = from({\n    prefix: '\\x00',\n    name: 'identity',\n    encode: (buf) => toString(buf),\n    decode: (str) => fromString(str)\n});\n//# sourceMappingURL=identity.js.map","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 0x0200;\nexport function encode(node) {\n    return textEncoder.encode(JSON.stringify(node));\n}\nexport function decode(data) {\n    return JSON.parse(textDecoder.decode(data));\n}\n//# sourceMappingURL=json.js.map","import { coerce } from '../bytes.js';\nexport const name = 'raw';\nexport const code = 0x55;\nexport function encode(node) {\n    return coerce(node);\n}\nexport function decode(data) {\n    return coerce(data);\n}\n//# sourceMappingURL=raw.js.map","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0x0;\nconst name = 'identity';\nconst encode = coerce;\nfunction digest(input) {\n    return Digest.create(code, encode(input));\n}\nexport const identity = { code, name, encode, digest };\n//# sourceMappingURL=identity.js.map","import * as Digest from './digest.js';\nexport function from({ name, code, encode }) {\n    return new Hasher(name, code, encode);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher {\n    name;\n    code;\n    encode;\n    constructor(name, code, encode) {\n        this.name = name;\n        this.code = code;\n        this.encode = encode;\n    }\n    digest(input) {\n        if (input instanceof Uint8Array) {\n            const result = this.encode(input);\n            return result instanceof Uint8Array\n                ? Digest.create(this.code, result)\n                /* c8 ignore next 1 */\n                : result.then(digest => Digest.create(this.code, digest));\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n            /* c8 ignore next 1 */\n        }\n    }\n}\n//# sourceMappingURL=hasher.js.map","/* global crypto */\nimport { from } from './hasher.js';\nfunction sha(name) {\n    return async (data) => new Uint8Array(await crypto.subtle.digest(name, data));\n}\nexport const sha256 = from({\n    name: 'sha2-256',\n    code: 0x12,\n    encode: sha('SHA-256')\n});\nexport const sha512 = from({\n    name: 'sha2-512',\n    code: 0x13,\n    encode: sha('SHA-512')\n});\n//# sourceMappingURL=sha2-browser.js.map","import * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base2 from './bases/base2.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base8 from './bases/base8.js';\nimport * as identityBase from './bases/identity.js';\nimport * as json from './codecs/json.js';\nimport * as raw from './codecs/raw.js';\nimport * as identity from './hashes/identity.js';\nimport * as sha2 from './hashes/sha2.js';\nimport { CID, hasher, digest, varint, bytes } from './index.js';\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji };\nexport const hashes = { ...sha2, ...identity };\nexport const codecs = { raw, json };\nexport { CID, hasher, digest, varint, bytes };\n//# sourceMappingURL=basics.js.map","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '#alloc';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc.js.map","/**\n * @packageDocumentation\n *\n * A suite of util methods that provides efficient validation.\n *\n * Detection of IPFS Paths and identifiers in URLs is a two-stage process:\n *\n * 1. `pathPattern`/`pathGatewayPattern`/`subdomainGatewayPattern` regex is applied to quickly identify potential candidates\n * 2. proper CID validation is applied to remove false-positives\n *\n * @example\n *\n * ```TypeScript\n * import * as isIPFS from 'is-ipfs'\n *\n * isIPFS.multihash('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.multihash('noop') // false\n *\n * isIPFS.cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true (CIDv0)\n * isIPFS.cid('bafybeiasb5vpmaounyilfuxbd3lryvosl4yefqrfahsb2esg46q6tu6y5q') // true (CIDv1 in Base32)\n * isIPFS.cid('zdj7WWeQ43G6JJvLWQWZpyHuAMq6uYWRjkBXFad11vE2LHhQ7') // true (CIDv1 in Base58btc)\n * isIPFS.cid('noop') // false\n *\n * isIPFS.base32cid('bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va') // true\n * isIPFS.base32cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n *\n * isIPFS.url('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.url('https://ipfs.io/ipfs/QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR?filename=guardian.jpg') // true\n * isIPFS.url('https://ipfs.io/ipns/github.com') // true\n * isIPFS.url('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.url('http://en.wikipedia-on-ipfs.org.ipfs.localhost:8080') // true\n * isIPFS.url('https://github.com/ipfs/js-ipfs/blob/master/README.md') // false\n * isIPFS.url('https://google.com') // false\n *\n * isIPFS.path('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.path('/ipfs/QmbcBPAwCDxRMB1Qe7CRQmxdrTSkxKwM9y6rZw2FjGtbsb/?weird-filename=test.jpg') // true\n * isIPFS.path('/ipns/github.com') // true\n * isIPFS.path('/ipfs/js-ipfs/blob/master/README.md') // false\n *\n * isIPFS.urlOrPath('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('https://ipfs.io/ipns/github.com') // true\n * isIPFS.urlOrPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('/ipns/github.com') // true\n * isIPFS.urlOrPath('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.urlOrPath('https://google.com') // false\n *\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsUrl('https://ipfs.io/ipns/github.com') // true\n *\n * isIPFS.ipfsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsPath('/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsPath('/ipns/github.com') // true\n *\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/path/to/file') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/file') // false\n *\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.subdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.subdomain('http://www.bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // false\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://QmcNioXSC1bfJj1dcFErhUfyjFzoX2HodkRccsFFVJJvg8.ipns.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://en.wikipedia-on-ipfs.org.ipns.localhost:8080') // true (assuming DNSLink)\n * isIPFS.ipnsSubdomain('http://en-wikipedia--on--ipfs-org.ipns.localhost:8080') // true (assuming inlined DNSLink)\n * isIPFS.ipnsSubdomain('http://hostname-without-tld-.ipns.dweb.link') // false (not a CID, invalid DNS label)\n *\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234') // true\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234/http') // true\n * isIPFS.multiaddr('/ip6/::1/udp/1234') // true\n * isIPFS.multiaddr('ip6/::1/udp/1234') // false\n * isIPFS.multiaddr('/yoloinvalid/::1/udp/1234') // false\n *\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true\n * isIPFS.peerMultiaddr('/ipfs/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true (legacy notation)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/tcp/1234/ws/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4/p2p-circuit/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io') // false (key missing, needs additional DNS lookup to tell if this is valid)\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN') // true (key present, ip and port can be resolved later)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/udp/1234') // false (key missing)\n * ```\n */\nimport * as mafmt from '@multiformats/mafmt';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { URL } from 'iso-url';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/;\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 2;\n// CID, libp2p-key or DNSLink\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/;\nconst subdomainIdMatch = 1;\nconst subdomainProtocolMatch = 2;\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;\nfunction isMultihash(hash) {\n    const formatted = convertToString(hash);\n    if (formatted === false) {\n        return false;\n    }\n    try {\n        Digest.decode(base58btc.decode(`z${formatted}`));\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\nfunction isMultiaddr(input) {\n    try {\n        return Boolean(multiaddr(input));\n    }\n    catch {\n        return false;\n    }\n}\nfunction isBase32EncodedMultibase(hash) {\n    try {\n        let cid;\n        if (isString(hash)) {\n            cid = CID.parse(hash);\n        }\n        else {\n            cid = CID.asCID(hash);\n        }\n        if (cid == null) {\n            return false;\n        }\n        base32.decode(cid.toString());\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\nfunction isCID(hash) {\n    try {\n        if (isString(hash)) {\n            return Boolean(CID.parse(hash));\n        }\n        if (hash instanceof Uint8Array) {\n            return Boolean(CID.decode(hash));\n        }\n        return Boolean(CID.asCID(hash)); // eslint-disable-line no-new\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr(input) {\n    return isMultiaddr(input) && mafmt.P2P.matches(input);\n}\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n    const formatted = convertToString(input);\n    if (formatted === false) {\n        return false;\n    }\n    const match = formatted.match(pattern);\n    if (match == null) {\n        return false;\n    }\n    if (match[protocolMatch] !== 'ipfs') {\n        return false;\n    }\n    let hash = match[hashMatch];\n    if (hash != null && pattern === subdomainGatewayPattern) {\n        // when doing checks for subdomain context\n        // ensure hash is case-insensitive\n        // (browsers force-lowercase authority component anyway)\n        hash = hash.toLowerCase();\n    }\n    return isCID(hash);\n}\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n    const formatted = convertToString(input);\n    if (formatted === false) {\n        return false;\n    }\n    const match = formatted.match(pattern);\n    if (match == null) {\n        return false;\n    }\n    if (match[protocolMatch] !== 'ipns') {\n        return false;\n    }\n    let ipnsId = match[hashMatch];\n    if (ipnsId != null && pattern === subdomainGatewayPattern) {\n        // when doing checks for subdomain context\n        // ensure ipnsId is case-insensitive\n        // (browsers force-lowercase authority compotent anyway)\n        ipnsId = ipnsId.toLowerCase();\n        // Check if it is cidv1\n        if (isCID(ipnsId))\n            return true;\n        // Check if it looks like FQDN\n        try {\n            if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n                // name without tld, assuming its inlined into a single DNS label\n                // (https://github.com/ipfs/in-web-browsers/issues/169)\n                // en-wikipedia--on--ipfs-org → en.wikipedia-on-ipfs.org\n                ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');\n            }\n            // URL implementation in web browsers forces lowercase of the hostname\n            const { hostname } = new URL(`http://${ipnsId}`); // eslint-disable-line no-new\n            // Check if potential FQDN has an explicit TLD\n            return fqdnWithTld.test(hostname);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @param {any} input\n */\nfunction isString(input) {\n    return typeof input === 'string';\n}\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString(input) {\n    if (input instanceof Uint8Array) {\n        return uint8ArrayToString(input, 'base58btc');\n    }\n    if (isString(input)) {\n        return input;\n    }\n    return false;\n}\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS subdomain\n * (case-insensitive CIDv1) or `false` otherwise.\n */\nexport const ipfsSubdomain = (url) => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * Returns `true` if the provided `url` string looks like a valid IPNS subdomain\n * (CIDv1 with `libp2p-key` multicodec or something that looks like a FQDN, for\n * example `en.wikipedia-on-ipfs.org.ipns.localhost:8080`) or `false` otherwise.\n *\n * **Note:** `ipnsSubdomain` method works in offline mode: it does not perform\n * actual IPNS record lookup over DHT or other content routing method. It may\n * return false-positives:\n *\n * - To ensure IPNS record  exists, make a call to `/api/v0/name/resolve?arg=<ipnsid>`\n * - To ensure DNSLink exists, make a call to `/api/v0/dns?arg=<fqdn>`\n */\nexport const ipnsSubdomain = (url) => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS, looks like\n * an IPNS/DNSLink subdomain or `false` otherwise.\n */\nexport const subdomain = (url) => ipfsSubdomain(url) || ipnsSubdomain(url);\n/**\n * Returns `true` if the provided string is a valid IPFS url or `false`\n * otherwise.\n */\nexport const ipfsUrl = (url) => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);\n/**\n * Returns `true` if the provided string is a valid IPNS url or `false`\n * otherwise.\n */\nexport const ipnsUrl = (url) => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or `false`\n * otherwise.\n */\nexport const url = (url) => ipfsUrl(url) || ipnsUrl(url) || subdomain(url);\nexport const path = (path) => isIpfs(path, pathPattern) || isIpns(path, pathPattern);\n/**\n * Returns `true` if the provided string or `Uint8Array`  is a valid `multihash`\n * or `false` otherwise.\n */\nexport { isMultihash as multihash };\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid multiaddr or `false` otherwise.\n */\nexport { isMultiaddr as multiaddr };\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid libp2p peer multiaddr (matching [`P2P`\n * format from `mafmt`](https://github.com/multiformats/js-mafmt#api)) or\n * `false` otherwise.\n */\nexport { isPeerMultiaddr as peerMultiaddr };\n/**\n * Returns `true` if the provided string, `Uint8Array` or [`CID`](https://github.com/multiformats/js-multiformats/#readme)\n * object represents a valid [CID](https://docs.ipfs.io/guides/concepts/cid/) or\n * `false` otherwise.\n */\nexport { isCID as cid };\n/**\n * Returns `true` if the provided string is a valid `CID` in Base32 encoding or\n * `false` otherwise.\n */\nexport const base32cid = (cid) => (isCID(cid) && isBase32EncodedMultibase(cid));\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS path or `false`\n * otherwise.\n */\nexport const ipfsPath = (path) => isIpfs(path, pathPattern);\n/**\n * Returns `true` if the provided string is a valid IPNS path or `false`\n * otherwise.\n */\nexport const ipnsPath = (path) => isIpns(path, pathPattern);\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or path or\n * `false` otherwise.\n */\nexport const urlOrPath = (x) => url(x) || path(x);\n/**\n * Returns `true` if the provided string is a valid \"CID path\" (IPFS path\n * without `/ipfs/` prefix) or `false` otherwise.\n */\nexport const cidPath = (path) => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern);\n//# sourceMappingURL=index.js.map","import bases, {} from './util/bases.js';\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString(array, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    // strip multibase prefix\n    return base.encoder.encode(array).substring(1);\n}\n//# sourceMappingURL=to-string.js.map"],"names":["URLWithLegacySupport","format","URLSearchParams","defaultBase","relative","module","exports","URL","url","location","protocolMap","defaultProtocol","urlParsed","protocol","replace","err","base","Object","assign","host","toString","isReactNative","navigator","product","self","constructor","this","super","path","pathname","search","auth","username","password","query","startsWith","slice","hash","hostname","href","origin","port","searchParams","createObjectURL","o","revokeObjectURL","toJSON","obj","userPass","Error","CodeError","code","props","message","name","coerce","Uint8Array","ArrayBuffer","isView","buffer","byteOffset","byteLength","AggregateError","ALPHABET","length","TypeError","BASE_MAP","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","size","b256","carry","it3","it4","vch","encode","Array","isArray","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","Encoder","prefix","baseEncode","bytes","Decoder","baseDecode","prefixCodePoint","undefined","codePointAt","text","JSON","stringify","or","decoder","ComposedDecoder","decoders","input","RangeError","keys","left","right","Codec","encoder","baseX","alphabet","rfc4648","bitsPerChar","data","pad","mask","out","bits","codes","end","written","value","SyntaxError","base58btc","base58flickr","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","MSB","MSBALL","INT","pow","MSB$1","REST$1","N1","N2","N3","N4","N5","N6","N7","N8","N9","num","offset","oldOffset","read","buf","b","res","shift","counter","l","encodingLength","encodeTo","int","target","create","digest","sizeOffset","digestOffset","set","Digest","multihash","subarray","link","version","cache","cid","get","toStringV0","baseCache","toStringV1","WeakMap","Map","CID","asCID","toV0","DAG_PB_CODE","SHA_256_CODE","createV0","toV1","createV1","equals","other","unknown","a","aa","bb","ii","Symbol","toStringTag","for","encodeCID","cidSymbol","remainder","decodeFirst","specs","inspectBytes","prefixSize","multihashSize","multihashBytes","digestBytes","digestSize","multihashCode","codec","initialBytes","next","parse","parseCIDtoBytes","codeOffset","hashOffset","base10","base16","base16upper","base2","alphabetBytesToChars","reduce","p","c","alphabetCharsToBytes","base256emoji","byts","char","byt","push","base36","base36upper","base64","base64pad","base64url","base64urlpad","base8","identity","TextDecoder","TextEncoder","fromString","textEncoder","textDecoder","node","Hasher","result","then","sha","async","crypto","subtle","sha256","sha512","bases","allocUnsafe","createCodec","substring","ascii","String","fromCharCode","utf8","hex","latin1","binary","array","encoding","Number","MAX_SAFE_INTEGER","encodeUint8Array","encodeUint8ArrayList","decodeUint8Array","decodeUint8ArrayList","concat","arrays","acc","curr","output","arr","MAX_IPV6_LENGTH","parser","index","readAtomically","fn","parseWith","peekChar","readChar","readGivenChar","readSeparator","sep","inner","readNumber","radix","maxDigits","allowZeroPrefix","maxBytes","digitCount","leadingChar","hasLeadingZero","maxValue","digit","parseInt","isNaN","readIPv4Addr","ix","readIPv6Addr","readGroups","groups","ipv4","group","head","headSize","headIp4","tail","limit","tailSize","readIPAddr","isIP","Boolean","includes","split","new","isV4","isV6","toBytes","ip","trim","forEach","byte","sections","v4Buffer","splice","unshift","argv","apply","word","view","DataView","join","getUint16","V","names","proto","convertToString","ipBuff","ipString","bytes2ip","bytes2str","bytes2port","address","bytes2mh","addrBytes","portBytes","bytes2onion","bytes2mb","globalThis","encodeURIComponent","convertToBytes","ip2bytes","str2bytes","port2bytes","mh","mh2bytes","addr","portBuf","onion2bytes","onion32bytes","mbstr","mb","anybaseDecoder","mb2bytes","decodeURIComponent","row","resolvable","createProtocol","values","map","d","setUint16","bytesToMultiaddrParts","tuples","stringTuples","n","sizeForAddr","ParseError","stringAddr","stringTuplesToString","parts","tup","cleanPath","tuplesToBytes","filter","inspect","symbol","DNS_CODES","Multiaddr","stringToMultiaddrParts","toOptions","family","transport","zone","tcp","udp","ip4","ip6","dns6","ip6zone","protos","protoCodes","protoNames","encapsulate","decapsulate","addrString","s","lastIndexOf","decapsulateCode","getPeerId","p2p","tuple","pop","peerIdStr","e","getPath","resolve","options","resolvableProto","find","resolver","resolvers","nodeAddress","isThinWaistAddress","DNS4","DNS6","DNSADDR","DNS","IP","TCP","and","UDP","UTP","QUIC","QUICV1","_WebSockets","WebSockets","_WebSocketsSecure","WebSocketsSecure","HTTP","HTTPS","_WebRTCDirect","WebRTCDirect","_WebTransport","WebTransport","P2PWebRTCStar","P2PWebRTCDirect","Reliable","_P2P","_Circuit","CircuitRecursive","Circuit","P2P","makeMatchesFunction","partialMatch","ma","args","some","arg","matches","pnames","pathGatewayPattern","pathPattern","subdomainGatewayPattern","fqdnWithTld","isMultihash","formatted","isCID","isString","isPeerMultiaddr","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","ipnsId","test","ipfsSubdomain","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","base32cid","isBase32EncodedMultibase","ipfsPath","ipnsPath","urlOrPath","cidPath"],"sourceRoot":""}